__start:
__text_start:
      D5 EFCF      LDI	R28,0xFF
      D6 E2D1      LDI	R29,0x21
      D7 BFCD      OUT	0x3D,R28
      D8 BFDE      OUT	0x3E,R29
      D9 51C0      SUBI	R28,0x10
      DA 40D0      SBCI	R29,0
      DB EA0A      LDI	R16,0xAA
      DC 8308      STD	Y+0,R16
      DD 2400      CLR	R0
      DE E0EE      LDI	R30,0xE
      DF E0F2      LDI	R31,2
      E0 E012      LDI	R17,2
      E1 36E5      CPI	R30,0x65
      E2 07F1      CPC	R31,R17
      E3 F011      BEQ	0x00E6
      E4 9201      ST	R0,Z+
      E5 CFFB      RJMP	0x00E1
      E6 8300      STD	Z+0,R16
      E7 E9EC      LDI	R30,0x9C
      E8 E0F1      LDI	R31,1
      E9 E0A0      LDI	R26,0
      EA E0B2      LDI	R27,2
      EB E011      LDI	R17,1
      EC E000      LDI	R16,0
      ED BF0B      OUT	0x3B,R16
      EE 3AEA      CPI	R30,0xAA
      EF 07F1      CPC	R31,R17
      F0 F021      BEQ	0x00F5
      F1 95C8      LPM
      F2 9631      ADIW	R30,1
      F3 920D      ST	R0,X+
      F4 CFF9      RJMP	0x00EE
      F5 940E 00F8 CALL	_main
_exit:
      F7 CFFF      RJMP	_exit
_main:
  i                    --> R20
      F8 9722      SBIW	R28,2
FILE: D:\BUILDI~1\main.c
(0001) /**
(0002) @mainpage Building a locamotion based Hexapod Application
(0003) @author Group 6 Srijit Dutt 10305056
(0004) 
(0005) Mon 08 Nov 2010 12:49:10 AM IST 
(0006) 
(0007) ICC AVR 7
(0008) 
(0009) Conatins various functions for basic, advanced hexapod motions
(0010) 
(0011) 
(0012) */
(0013) 
(0014) /*********************************************************************************
(0015) 
(0016)    Copyright (c) 2010, ERTS Lab IIT Bombay erts@cse.iitb.ac.in               -*- c -*-
(0017)    All rights reserved.
(0018) 
(0019)    Redistribution and use in source and binary forms, with or without
(0020)    modification, are permitted provided that the following conditions are met:
(0021) 
(0022)    * Redistributions of source code must retain the above copyright
(0023)      notice, this list of conditions and the following disclaimer.
(0024) 
(0025)    * Redistributions in binary form must reproduce the above copyright
(0026)      notice, this list of conditions and the following disclaimer in
(0027)      the documentation and/or other materials provided with the
(0028)      distribution.
(0029) 
(0030)    * Neither the name of the copyright holders nor the names of
(0031)      contributors may be used to endorse or promote products derived
(0032)      from this software without specific prior written permission.
(0033) 
(0034)    * Source code can be used for academic purpose. 
(0035) 	 For commercial use permission form the author needs to be taken.
(0036) 
(0037)   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
(0038)   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
(0039)   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
(0040)   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
(0041)   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
(0042)   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
(0043)   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
(0044)   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
(0045)   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
(0046)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
(0047)   POSSIBILITY OF SUCH DAMAGE. 
(0048) 
(0049)   Software released under Creative Commence cc by-nc-sa licence.
(0050)   For legal information refer to: 
(0051)   http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode
(0052) 
(0053) ********************************************************************************/
(0054) 
(0055) 
(0056) #include <iom2560v.h>
(0057) #include <macros.h>
(0058) #include "hexapod_macro.h"
(0059) #include "hexapod.h"
(0060) #include "hexapod_basic.h"
(0061) #include "hexapod_motions.h"
(0062) #include "gait.h"
(0063) #include "keyboard.h"
(0064) 
(0065) extern unsigned char data;
(0066) 
(0067) 
(0068) 
(0069) /**
(0070) The main function used to call other functions
(0071) */
(0072) void main(void) {
(0073) 
(0074) 	int i = 100;
      F9 E644      LDI	R20,0x64
      FA E050      LDI	R21,0
(0075) 	init_devices();
      FB 940E 07FF CALL	_init_devices
(0076) 	//insert your functional code here...
(0077) 	servo_calibration(); //must be called as the first instruction
      FD 940E 09DD CALL	_servo_calibration
(0078) 	servo_on();//turning on the servo supply
      FF 940E 085B CALL	_servo_on
(0079) 	initializeAngles();
     101 940E 0BDA CALL	_initializeAngles
(0080) 	delay(ONE_SEC);
     103 E900      LDI	R16,0x90
     104 E011      LDI	R17,1
     105 940E 0BAA CALL	_delay
(0081) 	delay(ONE_SEC);
     107 E900      LDI	R16,0x90
     108 E011      LDI	R17,1
     109 940E 0BAA CALL	_delay
(0082) 	delay(ONE_SEC);
     10B E900      LDI	R16,0x90
     10C E011      LDI	R17,1
     10D 940E 0BAA CALL	_delay
(0083) 
(0084) 	//angle_XA(0);
(0085) 	//angle_XB(0);
(0086) 	//angle_XC(0);
(0087) 	//delay_1s();
(0088) 	//delay_1s();
(0089) 	//angle_XA(180);
(0090) 	//angle_XB(180);
(0091) 	//angle_XC(180);
(0092) 
(0093) 	//angle(1, MOTOR_B, 40);
(0094) 	//angle(3, MOTOR_B, 40);
(0095) 	//angle(5, MOTOR_B, 40);
(0096) 	//angle(LEG_2, MOTOR_A, 0);
(0097) 	//angle(4, MOTOR_B, 0);
(0098) 	//angle(6, MOTOR_B, 0);
(0099) 		
(0100) 	//tripod_gait(1, 10);
(0101) 	//tripod_gait(2, 10);
(0102) 	//tripod_gait(3, 10);
(0103) 	//tripod_gait(4, 10);
(0104) 	//tripod_gait(5, 10);
(0105) 	//tripod_gait(6, 10);
(0106) 	
(0107) 	//two_leg_gait(1, 2, 10);
(0108) 	//two_leg_gait(2, 3, 10);
(0109) 	//two_leg_gait(3, 6, 10);
(0110) 	//two_leg_gait(6, 5, 10);
(0111) 	//two_leg_gait(5, 4, 10);
(0112) 	//two_leg_gait(4, 1, 10);
(0113) 	
(0114) 	
(0115) 	
(0116) 	//robot_rotate_clockwise_7_5();
(0117) 	
(0118) 	
(0119) 	/*
(0120) 	dance(1,2,10);
(0121) 	
(0122) 	
(0123) 	delay(ONE_SEC);
(0124) 	servo_calibration();
(0125) 	
(0126) 	pose(1, 2, 10);
(0127) 	*/
(0128) 		
(0129) 	//delay(ONE_SEC);
(0130) 	//servo_calibration();
(0131) 	
(0132) 	//dance(4,5,10);
(0133) 	
(0134) 	//delay(ONE_SEC);
(0135) 	
(0136) 	//sway(24, CLOCK_WISE);
(0137) 	
(0138) 	//climb();
(0139) 	
(0140) 	
(0141) 	
(0142) 	//tripod_gait_2(LEG_1, 30);
(0143) 	
(0144) 	//delay(ONE_SEC);
(0145) 	
(0146) 	//walk_on_four();
(0147) 	
(0148) 	//servo_calibration();
(0149) 	
(0150) 	
(0151) 	//setMirrorDir(DIR_MIRROR_LEG_1_2);
(0152) 	//angleMirror(LEG_1, MOTOR_A, 0);
(0153) 	//angleMirror(LEG_4, MOTOR_A, 0);
(0154) 	//angleMirror(LEG_5, MOTOR_A, 0);
(0155) 	
(0156) 	//delay(ONE_SEC);
(0157) 	
(0158) 	//angleMirror(LEG_1, MOTOR_A, 180);
(0159) 	//angleMirror(LEG_4, MOTOR_A, 180);
(0160) 	//angleMirror(LEG_5, MOTOR_A, 180);
(0161) 
(0162) 	/*
(0163) 	angleMirror(LEG_1, MOTOR_B, 0);
(0164) 	angleMirror(LEG_4, MOTOR_B, 0);
(0165) 	angleMirror(LEG_5, MOTOR_B, 0);
(0166) 	
(0167) 	delay(ONE_SEC);
(0168) 	
(0169) 	angleMirror(LEG_1, MOTOR_B, 180);
(0170) 	angleMirror(LEG_4, MOTOR_B, 180);
(0171) 	angleMirror(LEG_5, MOTOR_B, 180);
(0172) 	*/
(0173) 	
(0174) 	/*
(0175) 	angleMirror(LEG_1, MOTOR_C, 0);
(0176) 	angleMirror(LEG_4, MOTOR_C, 0);
(0177) 	angleMirror(LEG_5, MOTOR_C, 0);
(0178) 		
(0179) 	delay(ONE_SEC);
(0180) 	
(0181) 	angleMirror(LEG_1, MOTOR_C, 180);
(0182) 	angleMirror(LEG_4, MOTOR_C, 180);
(0183) 	angleMirror(LEG_5, MOTOR_C, 180);
(0184) 	*/
(0185) 	
(0186) 	/* Testing Remaining
(0187) 	angleMirrorChange(LEG_1, MOTOR_C, 90);
(0188) 	angleMirrorChange(LEG_4, MOTOR_C, 90);
(0189) 	angleMirrorChange(LEG_5, MOTOR_C, 90);
(0190) 	*/
(0191) 	
(0192) 	
(0193) 	/*
(0194) 	while(1) {
(0195) 		keyboard_control();
(0196) 		delay(TWO_HUNDRED_FIFTY_MSEC);	 
(0197) 	}
(0198) 	*/
(0199) 	 
(0200) 	/*
(0201) 	tripod_gait(LEG_1, 6);
(0202) 	
(0203) 	//two_leg_gait(LEG_1, LEG_2, 6);
(0204) 	
(0205) 	delay(ONE_SEC);
(0206) 	
(0207) 	robot_rotate_clockwise_7_5();
(0208) 	
(0209) 	delay(HUNDRED_MSEC);
(0210) 	
(0211) 	robot_rotate_clockwise_7_5();
(0212) 	
(0213) 	delay(HUNDRED_MSEC);
(0214) 	
(0215) 	robot_rotate_clockwise_7_5();
(0216) 	
(0217) 	delay(HUNDRED_MSEC);
(0218) 	
(0219) 	
(0220) 	tripod_gait(LEG_2, 2);
(0221) 	
(0222) 	*/
(0223) 	
(0224) 	delay(ONE_SEC);
     10F E900      LDI	R16,0x90
     110 E011      LDI	R17,1
     111 940E 0BAA CALL	_delay
(0225) 	
(0226) 	//servo_calibration();
(0227) 	
(0228) 	delay(ONE_SEC);
     113 E900      LDI	R16,0x90
     114 E011      LDI	R17,1
     115 940E 0BAA CALL	_delay
(0229) 		
(0230) 	climb();
     117 940E 105C CALL	_climb
(0231) 	
(0232) 	//delay(ONE_SEC);
(0233) 	delay(ONE_SEC);
     119 E900      LDI	R16,0x90
     11A E011      LDI	R17,1
     11B 940E 0BAA CALL	_delay
(0234) 	
(0235) 	/*
(0236) 	buzzer_on();
(0237) 	delay(ONE_SEC);
(0238) 	buzzer_off();
(0239) 	
(0240) 	
(0241) 	i = 100;
(0242) 	while(i-- > 0) {
(0243) 		keyboard_control();
(0244) 		delay(TWO_HUNDRED_FIFTY_MSEC);	 
(0245) 	}
(0246) 	*/
(0247) 	
(0248) 	
(0249) 	tripod_gait(LEG_2, 2);
     11D E022      LDI	R18,2
     11E E002      LDI	R16,2
     11F 940E 016B CALL	_tripod_gait
(0250) 	
(0251) 	delay(ONE_SEC);
     121 E900      LDI	R16,0x90
     122 E011      LDI	R17,1
     123 940E 0BAA CALL	_delay
(0252) 	
(0253) 	dance(4,5,6);
     125 E086      LDI	R24,6
     126 E090      LDI	R25,0
     127 8399      STD	Y+1,R25
     128 8388      STD	Y+0,R24
     129 E025      LDI	R18,5
     12A E004      LDI	R16,4
     12B 940E 0EA7 CALL	_dance
(0254) 	
(0255) 	delay(ONE_SEC);
     12D E900      LDI	R16,0x90
     12E E011      LDI	R17,1
     12F 940E 0BAA CALL	_delay
(0256) 	
(0257) 	servo_calibration();
     131 940E 09DD CALL	_servo_calibration
(0258) 	
(0259) 	delay(ONE_SEC);
     133 E900      LDI	R16,0x90
     134 E011      LDI	R17,1
     135 940E 0BAA CALL	_delay
(0260) 		
(0261) 	sway(24, CLOCK_WISE);
     137 E021      LDI	R18,1
     138 E108      LDI	R16,0x18
     139 E010      LDI	R17,0
     13A 940E 0F52 CALL	_sway
(0262) 	
(0263) 	delay(ONE_SEC);
     13C E900      LDI	R16,0x90
     13D E011      LDI	R17,1
     13E 940E 0BAA CALL	_delay
(0264) 	
(0265) 	servo_calibration();
     140 940E 09DD CALL	_servo_calibration
(0266) 	
(0267) 	delay(ONE_SEC);
     142 E900      LDI	R16,0x90
     143 E011      LDI	R17,1
     144 940E 0BAA CALL	_delay
(0268) 	
(0269) 	pose(3, 6, 10);
     146 E08A      LDI	R24,0xA
     147 E090      LDI	R25,0
     148 8399      STD	Y+1,R25
     149 8388      STD	Y+0,R24
     14A E026      LDI	R18,6
     14B E003      LDI	R16,3
     14C 940E 0DD8 CALL	_pose
(0270) 	
(0271) 	delay(ONE_SEC);
     14E E900      LDI	R16,0x90
     14F E011      LDI	R17,1
     150 940E 0BAA CALL	_delay
(0272) 	
(0273) 	servo_calibration();
     152 940E 09DD CALL	_servo_calibration
(0274) 	
(0275) 	delay(ONE_SEC);
     154 E900      LDI	R16,0x90
     155 E011      LDI	R17,1
     156 940E 0BAA CALL	_delay
(0276) 	
(0277) 	dance(4,5,6);
     158 E086      LDI	R24,6
     159 E090      LDI	R25,0
     15A 8399      STD	Y+1,R25
     15B 8388      STD	Y+0,R24
     15C E025      LDI	R18,5
     15D E004      LDI	R16,4
     15E 940E 0EA7 CALL	_dance
(0278) 	
(0279) 	delay(ONE_SEC);
     160 E900      LDI	R16,0x90
     161 E011      LDI	R17,1
     162 940E 0BAA CALL	_delay
(0280) 	
(0281) 	sway(24, ANTI_CLOCK_WISE);
     164 2722      CLR	R18
     165 E108      LDI	R16,0x18
     166 E010      LDI	R17,0
     167 940E 0F52 CALL	_sway
     169 9622      ADIW	R28,2
     16A 9508      RET
_tripod_gait:
  step_forward         --> R20
  delay_time           --> R14
  step_side            --> R12
  dir6                 --> R10
  dir4                 --> Y,+4
  dir2                 --> Y,+3
  dir5                 --> Y,+2
  dir3                 --> Y,+1
  lift                 --> R22
  steps                --> Y,+17
  dir1                 --> Y,+15
     16B 940E 1379 CALL	push_arg4
     16D 940E 13BA CALL	push_xgsetF0FC
     16F 9725      SBIW	R28,5
FILE: D:\BUILDI~1\gait.c
(0001) /***
(0002) Author : Srijit Dutt
(0003) Date Sun 07 Nov 2010 02:42:38 PM IST 
(0004) 
(0005) gait.c : File contains various walking motion functions for the hexapod
(0006) Please include gait.h file to call function from this file
(0007) 
(0008) */
(0009) 
(0010) 
(0011) /********************************************************************************
(0012) 
(0013)    Copyright (c) 2010, ERTS Lab IIT Bombay erts@cse.iitb.ac.in               -*- c -*-
(0014)    All rights reserved.
(0015) 
(0016)    Redistribution and use in source and binary forms, with or without
(0017)    modification, are permitted provided that the following conditions are met:
(0018) 
(0019)    * Redistributions of source code must retain the above copyright
(0020)      notice, this list of conditions and the following disclaimer.
(0021) 
(0022)    * Redistributions in binary form must reproduce the above copyright
(0023)      notice, this list of conditions and the following disclaimer in
(0024)      the documentation and/or other materials provided with the
(0025)      distribution.
(0026) 
(0027)    * Neither the name of the copyright holders nor the names of
(0028)      contributors may be used to endorse or promote products derived
(0029)      from this software without specific prior written permission.
(0030) 
(0031)    * Source code can be used for academic purpose. 
(0032) 	 For commercial use permission form the author needs to be taken.
(0033) 
(0034)   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
(0035)   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
(0036)   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
(0037)   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
(0038)   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
(0039)   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
(0040)   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
(0041)   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
(0042)   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
(0043)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
(0044)   POSSIBILITY OF SUCH DAMAGE. 
(0045) 
(0046)   Software released under Creative Commence cc by-nc-sa licence.
(0047)   For legal information refer to: 
(0048)   http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode
(0049) 
(0050) ********************************************************************************/
(0051) 
(0052) 
(0053) #include "hexapod_macro.h"
(0054) #include "hexapod_basic.h"
(0055) #include "hexapod.h"
(0056) 
(0057) 
(0058) /**
(0059) Tripod gait moves the hexapod in the direction dir1 for steps.
(0060) Three legs forming a tripod move first then the other three legs move  
(0061) Used for normal gait of the hexapod
(0062) @param dir1 : Direction of motion
(0063) @param steps : number of steps
(0064) 
(0065) */
(0066) void tripod_gait(unsigned char dir1, unsigned char steps) {
(0067) 	unsigned char dir3 = ((dir1 + 1) % 6) + 1;
     170 E016      LDI	R17,6
     171 850F      LDD	R16,Y+15
     172 5F0F      SUBI	R16,0xFF
     173 940E 137E CALL	mod8u
     175 2F80      MOV	R24,R16
     176 5F8F      SUBI	R24,0xFF
     177 8389      STD	Y+1,R24
(0068) 	unsigned char dir5 = ((dir3 + 1) % 6) + 1;
     178 E016      LDI	R17,6
     179 2F08      MOV	R16,R24
     17A 5F0F      SUBI	R16,0xFF
     17B 940E 137E CALL	mod8u
     17D 2F80      MOV	R24,R16
     17E 5F8F      SUBI	R24,0xFF
     17F 838A      STD	Y+2,R24
(0069) 	unsigned char dir2 = 7 - dir5;
     180 2E28      MOV	R2,R24
     181 E087      LDI	R24,7
     182 1982      SUB	R24,R2
     183 838B      STD	Y+3,R24
(0070) 	unsigned char dir4 = 7 - dir3;
     184 8029      LDD	R2,Y+1
     185 E087      LDI	R24,7
     186 1982      SUB	R24,R2
     187 838C      STD	Y+4,R24
(0071) 	unsigned char dir6 = 7 - dir1;
     188 E087      LDI	R24,7
     189 2EA8      MOV	R10,R24
     18A 840F      LDD	R0,Y+15
     18B 18A0      SUB	R10,R0
(0072) 	unsigned char step_forward = 70;
     18C E446      LDI	R20,0x46
(0073) 	unsigned char step_side = 50;
     18D E382      LDI	R24,0x32
     18E 2EC8      MOV	R12,R24
(0074) 	unsigned char lift = 40;
     18F E268      LDI	R22,0x28
(0075) 	int delay_time = TWO_HUNDRED_FIFTY_MSEC;
     190 E684      LDI	R24,0x64
     191 E090      LDI	R25,0
     192 017C      MOVW	R14,R24
(0076) 	
(0077) 	
(0078) 	if(dir1%2 == 0) {
     193 E012      LDI	R17,2
     194 2D00      MOV	R16,R0
     195 940E 137E CALL	mod8u
     197 2300      TST	R16
     198 F009      BEQ	0x019A
     199 C0B5      RJMP	0x024F
(0079) 		swap(&dir2, &dir4);
     19A 019E      MOVW	R18,R28
     19B 5F2C      SUBI	R18,0xFC
     19C 4F3F      SBCI	R19,0xFF
     19D 018E      MOVW	R16,R28
     19E 5F0D      SUBI	R16,0xFD
     19F 4F1F      SBCI	R17,0xFF
     1A0 940E 0D0A CALL	_swap
(0080) 		swap(&dir3, &dir5);	  
     1A2 019E      MOVW	R18,R28
     1A3 5F2E      SUBI	R18,0xFE
     1A4 4F3F      SBCI	R19,0xFF
     1A5 018E      MOVW	R16,R28
     1A6 5F0F      SUBI	R16,0xFF
     1A7 4F1F      SBCI	R17,0xFF
     1A8 940E 0D0A CALL	_swap
(0081) 	}
     1AA C0A4      RJMP	0x024F
(0082) 	
(0083) 	while (steps-- > 0) {
(0084) 
(0085) 		//puuting down odd tripod
(0086) 		angle(dir1, MOTOR_B, 90);
     1AB E58A      LDI	R24,0x5A
     1AC 8388      STD	Y+0,R24
     1AD E422      LDI	R18,0x42
     1AE 850F      LDD	R16,Y+15
     1AF 940E 0BFD CALL	_angle
(0087) 		angle(dir3, MOTOR_B, 90);
     1B1 E58A      LDI	R24,0x5A
     1B2 8388      STD	Y+0,R24
     1B3 E422      LDI	R18,0x42
     1B4 8109      LDD	R16,Y+1
     1B5 940E 0BFD CALL	_angle
(0088) 		angle(dir5, MOTOR_B, 90);
     1B7 E58A      LDI	R24,0x5A
     1B8 8388      STD	Y+0,R24
     1B9 E422      LDI	R18,0x42
     1BA 810A      LDD	R16,Y+2
     1BB 940E 0BFD CALL	_angle
(0089) 		
(0090) 		delay(HUNDRED_MSEC);
     1BD E208      LDI	R16,0x28
     1BE E010      LDI	R17,0
     1BF 940E 0BAA CALL	_delay
(0091) 		
(0092) 		//picking up even tripod
(0093) 		angle(dir2, MOTOR_B, lift);
     1C1 8368      STD	Y+0,R22
     1C2 E422      LDI	R18,0x42
     1C3 810B      LDD	R16,Y+3
     1C4 940E 0BFD CALL	_angle
(0094) 		angle(dir4, MOTOR_B, lift);
     1C6 8368      STD	Y+0,R22
     1C7 E422      LDI	R18,0x42
     1C8 810C      LDD	R16,Y+4
     1C9 940E 0BFD CALL	_angle
(0095) 		angle(dir6, MOTOR_B, lift);
     1CB 8368      STD	Y+0,R22
     1CC E422      LDI	R18,0x42
     1CD 2D0A      MOV	R16,R10
     1CE 940E 0BFD CALL	_angle
(0096) 		delay(delay_time);
     1D0 0187      MOVW	R16,R14
     1D1 940E 0BAA CALL	_delay
(0097) 
(0098) 		//moving body on odd tripod
(0099) 		angle(dir1, MOTOR_C, 90);
     1D3 E58A      LDI	R24,0x5A
     1D4 8388      STD	Y+0,R24
     1D5 E423      LDI	R18,0x43
     1D6 850F      LDD	R16,Y+15
     1D7 940E 0BFD CALL	_angle
(0100) 		angle(dir3, MOTOR_A, 90);
     1D9 E58A      LDI	R24,0x5A
     1DA 8388      STD	Y+0,R24
     1DB E421      LDI	R18,0x41
     1DC 8109      LDD	R16,Y+1
     1DD 940E 0BFD CALL	_angle
(0101) 		angle(dir5, MOTOR_A, 90);
     1DF E58A      LDI	R24,0x5A
     1E0 8388      STD	Y+0,R24
     1E1 E421      LDI	R18,0x41
     1E2 810A      LDD	R16,Y+2
     1E3 940E 0BFD CALL	_angle
(0102) 		//moving legs even forward in air
(0103) 		angle(dir2, MOTOR_A, 90 - step_side);
     1E5 E58A      LDI	R24,0x5A
     1E6 198C      SUB	R24,R12
     1E7 8388      STD	Y+0,R24
     1E8 E421      LDI	R18,0x41
     1E9 810B      LDD	R16,Y+3
     1EA 940E 0BFD CALL	_angle
(0104) 		angle(dir4, MOTOR_A, 90 + step_side);
     1EC 2D8C      MOV	R24,R12
     1ED 5A86      SUBI	R24,0xA6
     1EE 8388      STD	Y+0,R24
     1EF E421      LDI	R18,0x41
     1F0 810C      LDD	R16,Y+4
     1F1 940E 0BFD CALL	_angle
(0105) 		angle(dir6, MOTOR_C, 90 + step_forward);
     1F3 2F84      MOV	R24,R20
     1F4 5A86      SUBI	R24,0xA6
     1F5 8388      STD	Y+0,R24
     1F6 E423      LDI	R18,0x43
     1F7 2D0A      MOV	R16,R10
     1F8 940E 0BFD CALL	_angle
(0106) 		delay(delay_time);
     1FA 0187      MOVW	R16,R14
     1FB 940E 0BAA CALL	_delay
(0107) 
(0108) 		//putting down even legs
(0109) 		angle(dir2, MOTOR_B, 90);
     1FD E58A      LDI	R24,0x5A
     1FE 8388      STD	Y+0,R24
     1FF E422      LDI	R18,0x42
     200 810B      LDD	R16,Y+3
     201 940E 0BFD CALL	_angle
(0110) 		angle(dir4, MOTOR_B, 90);
     203 E58A      LDI	R24,0x5A
     204 8388      STD	Y+0,R24
     205 E422      LDI	R18,0x42
     206 810C      LDD	R16,Y+4
     207 940E 0BFD CALL	_angle
(0111) 		angle(dir6, MOTOR_B, 90);
     209 E58A      LDI	R24,0x5A
     20A 8388      STD	Y+0,R24
     20B E422      LDI	R18,0x42
     20C 2D0A      MOV	R16,R10
     20D 940E 0BFD CALL	_angle
(0112) 		
(0113) 		delay(HUNDRED_MSEC);
     20F E208      LDI	R16,0x28
     210 E010      LDI	R17,0
     211 940E 0BAA CALL	_delay
(0114) 		
(0115) 		//picking up odd legs
(0116) 		angle(dir1, MOTOR_B, lift);
     213 8368      STD	Y+0,R22
     214 E422      LDI	R18,0x42
     215 850F      LDD	R16,Y+15
     216 940E 0BFD CALL	_angle
(0117) 		angle(dir3, MOTOR_B, lift);
     218 8368      STD	Y+0,R22
     219 E422      LDI	R18,0x42
     21A 8109      LDD	R16,Y+1
     21B 940E 0BFD CALL	_angle
(0118) 		angle(dir5, MOTOR_B, lift);
     21D 8368      STD	Y+0,R22
     21E E422      LDI	R18,0x42
     21F 810A      LDD	R16,Y+2
     220 940E 0BFD CALL	_angle
(0119) 		delay(delay_time);
     222 0187      MOVW	R16,R14
     223 940E 0BAA CALL	_delay
(0120) 
(0121) 		//moving the odd legs in air
(0122) 		angle(dir1, MOTOR_C, 90 + step_forward);
     225 2F84      MOV	R24,R20
     226 5A86      SUBI	R24,0xA6
     227 8388      STD	Y+0,R24
     228 E423      LDI	R18,0x43
     229 850F      LDD	R16,Y+15
     22A 940E 0BFD CALL	_angle
(0123) 		angle(dir3, MOTOR_A, 90 - step_side);
     22C E58A      LDI	R24,0x5A
     22D 198C      SUB	R24,R12
     22E 8388      STD	Y+0,R24
     22F E421      LDI	R18,0x41
     230 8109      LDD	R16,Y+1
     231 940E 0BFD CALL	_angle
(0124) 		angle(dir5, MOTOR_A, 90 + step_side);
     233 2D8C      MOV	R24,R12
     234 5A86      SUBI	R24,0xA6
     235 8388      STD	Y+0,R24
     236 E421      LDI	R18,0x41
     237 810A      LDD	R16,Y+2
     238 940E 0BFD CALL	_angle
(0125) 		//moving the body forward on even tripod
(0126) 		angle(dir2, MOTOR_A, 90);
     23A E58A      LDI	R24,0x5A
     23B 8388      STD	Y+0,R24
     23C E421      LDI	R18,0x41
     23D 810B      LDD	R16,Y+3
     23E 940E 0BFD CALL	_angle
(0127) 		angle(dir4, MOTOR_A, 90);
     240 E58A      LDI	R24,0x5A
     241 8388      STD	Y+0,R24
     242 E421      LDI	R18,0x41
     243 810C      LDD	R16,Y+4
     244 940E 0BFD CALL	_angle
(0128) 		angle(dir6, MOTOR_C, 90);
     246 E58A      LDI	R24,0x5A
     247 8388      STD	Y+0,R24
     248 E423      LDI	R18,0x43
     249 2D0A      MOV	R16,R10
     24A 940E 0BFD CALL	_angle
(0129) 		delay(delay_time);
     24C 0187      MOVW	R16,R14
     24D 940E 0BAA CALL	_delay
     24F 8829      LDD	R2,Y+17
     250 2433      CLR	R3
     251 2D82      MOV	R24,R2
     252 5081      SUBI	R24,1
     253 8B89      STD	Y+17,R24
     254 E080      LDI	R24,0
     255 1582      CP	R24,R2
     256 F408      BCC	0x0258
     257 CF53      RJMP	0x01AB
     258 9625      ADIW	R28,5
     259 940E 13AF CALL	pop_xgsetF0FC
     25B 9624      ADIW	R28,4
     25C 9508      RET
_tripod_gait_2:
  delay_time1          --> R10
  step_forward         --> R20
  step_side            --> R14
  delay_time           --> R12
  lift                 --> R22
  dir6                 --> Y,+5
  dir4                 --> Y,+4
  dir2                 --> Y,+3
  dir5                 --> Y,+2
  dir3                 --> Y,+1
  steps                --> Y,+18
  dir1                 --> Y,+16
     25D 940E 1379 CALL	push_arg4
     25F 940E 13BA CALL	push_xgsetF0FC
     261 9726      SBIW	R28,6
(0130) 	}
(0131) }
(0132) 
(0133) /**
(0134) Tripod Gait 2 : Better suited for uneven terrain
(0135) @param dir1 : Direction of motion
(0136) @param steps : number of steps
(0137) */
(0138) void tripod_gait_2(unsigned char dir1, unsigned char steps) {
(0139) 	unsigned char dir3 = ((dir1 + 1) % 6) + 1;
     262 E016      LDI	R17,6
     263 8908      LDD	R16,Y+16
     264 5F0F      SUBI	R16,0xFF
     265 940E 137E CALL	mod8u
     267 2F80      MOV	R24,R16
     268 5F8F      SUBI	R24,0xFF
     269 8389      STD	Y+1,R24
(0140) 	unsigned char dir5 = ((dir3 + 1) % 6) + 1;
     26A E016      LDI	R17,6
     26B 2F08      MOV	R16,R24
     26C 5F0F      SUBI	R16,0xFF
     26D 940E 137E CALL	mod8u
     26F 2F80      MOV	R24,R16
     270 5F8F      SUBI	R24,0xFF
     271 838A      STD	Y+2,R24
(0141) 	unsigned char dir2 = 7 - dir5;
     272 2E28      MOV	R2,R24
     273 E087      LDI	R24,7
     274 1982      SUB	R24,R2
     275 838B      STD	Y+3,R24
(0142) 	unsigned char dir4 = 7 - dir3;
     276 8029      LDD	R2,Y+1
     277 E087      LDI	R24,7
     278 1982      SUB	R24,R2
     279 838C      STD	Y+4,R24
(0143) 	unsigned char dir6 = 7 - dir1;
     27A E087      LDI	R24,7
     27B 8808      LDD	R0,Y+16
     27C 1980      SUB	R24,R0
     27D 838D      STD	Y+5,R24
(0144) 	unsigned char step_forward = 60;
     27E E34C      LDI	R20,0x3C
(0145) 	unsigned char step_side = 60;
     27F E38C      LDI	R24,0x3C
     280 2EE8      MOV	R14,R24
(0146) 	unsigned char lift = 40;
     281 E268      LDI	R22,0x28
(0147) 	int delay_time = ONE_SEC;
     282 E980      LDI	R24,0x90
     283 E091      LDI	R25,1
     284 016C      MOVW	R12,R24
(0148) 	int delay_time1 = ONE_SEC;
     285 015C      MOVW	R10,R24
(0149) 	
(0150) 	
(0151) 	if(dir1%2 == 0) {
     286 E012      LDI	R17,2
     287 8908      LDD	R16,Y+16
     288 940E 137E CALL	mod8u
     28A 2300      TST	R16
     28B F009      BEQ	0x028D
     28C C125      RJMP	0x03B2
(0152) 		swap(&dir2, &dir4);
     28D 019E      MOVW	R18,R28
     28E 5F2C      SUBI	R18,0xFC
     28F 4F3F      SBCI	R19,0xFF
     290 018E      MOVW	R16,R28
     291 5F0D      SUBI	R16,0xFD
     292 4F1F      SBCI	R17,0xFF
     293 940E 0D0A CALL	_swap
(0153) 		swap(&dir3, &dir5);	  
     295 019E      MOVW	R18,R28
     296 5F2E      SUBI	R18,0xFE
     297 4F3F      SBCI	R19,0xFF
     298 018E      MOVW	R16,R28
     299 5F0F      SUBI	R16,0xFF
     29A 4F1F      SBCI	R17,0xFF
     29B 940E 0D0A CALL	_swap
(0154) 	}
     29D C114      RJMP	0x03B2
(0155) 	
(0156) 	while (steps-- > 0) {
(0157) 
(0158) 		//puuting down odd tripod
(0159) 		angle(dir1, MOTOR_C, 90);
     29E E58A      LDI	R24,0x5A
     29F 8388      STD	Y+0,R24
     2A0 E423      LDI	R18,0x43
     2A1 8908      LDD	R16,Y+16
     2A2 940E 0BFD CALL	_angle
(0160) 		angle(dir3, MOTOR_C, 90);
     2A4 E58A      LDI	R24,0x5A
     2A5 8388      STD	Y+0,R24
     2A6 E423      LDI	R18,0x43
     2A7 8109      LDD	R16,Y+1
     2A8 940E 0BFD CALL	_angle
(0161) 		angle(dir5, MOTOR_C, 90);
     2AA E58A      LDI	R24,0x5A
     2AB 8388      STD	Y+0,R24
     2AC E423      LDI	R18,0x43
     2AD 810A      LDD	R16,Y+2
     2AE 940E 0BFD CALL	_angle
(0162) 		angle(dir1, MOTOR_B, 90);
     2B0 E58A      LDI	R24,0x5A
     2B1 8388      STD	Y+0,R24
     2B2 E422      LDI	R18,0x42
     2B3 8908      LDD	R16,Y+16
     2B4 940E 0BFD CALL	_angle
(0163) 		angle(dir3, MOTOR_B, 90);
     2B6 E58A      LDI	R24,0x5A
     2B7 8388      STD	Y+0,R24
     2B8 E422      LDI	R18,0x42
     2B9 8109      LDD	R16,Y+1
     2BA 940E 0BFD CALL	_angle
(0164) 		angle(dir5, MOTOR_B, 90);
     2BC E58A      LDI	R24,0x5A
     2BD 8388      STD	Y+0,R24
     2BE E422      LDI	R18,0x42
     2BF 810A      LDD	R16,Y+2
     2C0 940E 0BFD CALL	_angle
(0165) 		
(0166) 				
(0167) 		delay(delay_time1);
     2C2 0185      MOVW	R16,R10
     2C3 940E 0BAA CALL	_delay
(0168) 		
(0169) 		//picking up even tripod
(0170) 		angle(dir2, MOTOR_B, lift);
     2C5 8368      STD	Y+0,R22
     2C6 E422      LDI	R18,0x42
     2C7 810B      LDD	R16,Y+3
     2C8 940E 0BFD CALL	_angle
(0171) 		angle(dir4, MOTOR_B, lift);
     2CA 8368      STD	Y+0,R22
     2CB E422      LDI	R18,0x42
     2CC 810C      LDD	R16,Y+4
     2CD 940E 0BFD CALL	_angle
(0172) 		angle(dir6, MOTOR_B, lift);
     2CF 8368      STD	Y+0,R22
     2D0 E422      LDI	R18,0x42
     2D1 810D      LDD	R16,Y+5
     2D2 940E 0BFD CALL	_angle
(0173) 		angle(dir2, MOTOR_C, 0);
     2D4 2422      CLR	R2
     2D5 8228      STD	Y+0,R2
     2D6 E423      LDI	R18,0x43
     2D7 810B      LDD	R16,Y+3
     2D8 940E 0BFD CALL	_angle
(0174) 		angle(dir4, MOTOR_C, 0);
     2DA 2422      CLR	R2
     2DB 8228      STD	Y+0,R2
     2DC E423      LDI	R18,0x43
     2DD 810C      LDD	R16,Y+4
     2DE 940E 0BFD CALL	_angle
(0175) 		angle(dir6, MOTOR_C, 0);
     2E0 2422      CLR	R2
     2E1 8228      STD	Y+0,R2
     2E2 E423      LDI	R18,0x43
     2E3 810D      LDD	R16,Y+5
     2E4 940E 0BFD CALL	_angle
(0176) 		delay(delay_time);
     2E6 0186      MOVW	R16,R12
     2E7 940E 0BAA CALL	_delay
(0177) 
(0178) 		//moving body on odd tripod
(0179) 		angle(dir1, MOTOR_A, 90);
     2E9 E58A      LDI	R24,0x5A
     2EA 8388      STD	Y+0,R24
     2EB E421      LDI	R18,0x41
     2EC 8908      LDD	R16,Y+16
     2ED 940E 0BFD CALL	_angle
(0180) 		angle(dir3, MOTOR_A, 90);
     2EF E58A      LDI	R24,0x5A
     2F0 8388      STD	Y+0,R24
     2F1 E421      LDI	R18,0x41
     2F2 8109      LDD	R16,Y+1
     2F3 940E 0BFD CALL	_angle
(0181) 		angle(dir5, MOTOR_A, 90);
     2F5 E58A      LDI	R24,0x5A
     2F6 8388      STD	Y+0,R24
     2F7 E421      LDI	R18,0x41
     2F8 810A      LDD	R16,Y+2
     2F9 940E 0BFD CALL	_angle
(0182) 		
(0183) 		delay(delay_time);
     2FB 0186      MOVW	R16,R12
     2FC 940E 0BAA CALL	_delay
(0184) 		
(0185) 		//moving legs even forward in air
(0186) 		angle(dir2, MOTOR_C, 180);
     2FE EB84      LDI	R24,0xB4
     2FF 8388      STD	Y+0,R24
     300 E423      LDI	R18,0x43
     301 810B      LDD	R16,Y+3
     302 940E 0BFD CALL	_angle
(0187) 		angle(dir4, MOTOR_C, 180);
     304 EB84      LDI	R24,0xB4
     305 8388      STD	Y+0,R24
     306 E423      LDI	R18,0x43
     307 810C      LDD	R16,Y+4
     308 940E 0BFD CALL	_angle
(0188) 		angle(dir6, MOTOR_C, 180);
     30A EB84      LDI	R24,0xB4
     30B 8388      STD	Y+0,R24
     30C E423      LDI	R18,0x43
     30D 810D      LDD	R16,Y+5
     30E 940E 0BFD CALL	_angle
(0189) 		angle(dir2, MOTOR_A, 90 - step_side);
     310 E58A      LDI	R24,0x5A
     311 198E      SUB	R24,R14
     312 8388      STD	Y+0,R24
     313 E421      LDI	R18,0x41
     314 810B      LDD	R16,Y+3
     315 940E 0BFD CALL	_angle
(0190) 		angle(dir4, MOTOR_A, 90 + step_side);
     317 2D8E      MOV	R24,R14
     318 5A86      SUBI	R24,0xA6
     319 8388      STD	Y+0,R24
     31A E421      LDI	R18,0x41
     31B 810C      LDD	R16,Y+4
     31C 940E 0BFD CALL	_angle
(0191) 		angle(dir6, MOTOR_A, 90 + step_forward);
     31E 2F84      MOV	R24,R20
     31F 5A86      SUBI	R24,0xA6
     320 8388      STD	Y+0,R24
     321 E421      LDI	R18,0x41
     322 810D      LDD	R16,Y+5
     323 940E 0BFD CALL	_angle
(0192) 		delay(delay_time);
     325 0186      MOVW	R16,R12
     326 940E 0BAA CALL	_delay
(0193) 
(0194) 		//putting down even legs
(0195) 		angle(dir2, MOTOR_C, 90);
     328 E58A      LDI	R24,0x5A
     329 8388      STD	Y+0,R24
     32A E423      LDI	R18,0x43
     32B 810B      LDD	R16,Y+3
     32C 940E 0BFD CALL	_angle
(0196) 		angle(dir4, MOTOR_C, 90);
     32E E58A      LDI	R24,0x5A
     32F 8388      STD	Y+0,R24
     330 E423      LDI	R18,0x43
     331 810C      LDD	R16,Y+4
     332 940E 0BFD CALL	_angle
(0197) 		angle(dir6, MOTOR_C, 90);
     334 E58A      LDI	R24,0x5A
     335 8388      STD	Y+0,R24
     336 E423      LDI	R18,0x43
     337 810D      LDD	R16,Y+5
     338 940E 0BFD CALL	_angle
(0198) 		angle(dir2, MOTOR_B, 90);
     33A E58A      LDI	R24,0x5A
     33B 8388      STD	Y+0,R24
     33C E422      LDI	R18,0x42
     33D 810B      LDD	R16,Y+3
     33E 940E 0BFD CALL	_angle
(0199) 		angle(dir4, MOTOR_B, 90);
     340 E58A      LDI	R24,0x5A
     341 8388      STD	Y+0,R24
     342 E422      LDI	R18,0x42
     343 810C      LDD	R16,Y+4
     344 940E 0BFD CALL	_angle
(0200) 		angle(dir6, MOTOR_B, 90);
     346 E58A      LDI	R24,0x5A
     347 8388      STD	Y+0,R24
     348 E422      LDI	R18,0x42
     349 810D      LDD	R16,Y+5
     34A 940E 0BFD CALL	_angle
(0201) 		
(0202) 		delay(delay_time1);
     34C 0185      MOVW	R16,R10
     34D 940E 0BAA CALL	_delay
(0203) 		
(0204) 		//picking up odd legs
(0205) 		angle(dir1, MOTOR_B, lift);
     34F 8368      STD	Y+0,R22
     350 E422      LDI	R18,0x42
     351 8908      LDD	R16,Y+16
     352 940E 0BFD CALL	_angle
(0206) 		angle(dir3, MOTOR_B, lift);
     354 8368      STD	Y+0,R22
     355 E422      LDI	R18,0x42
     356 8109      LDD	R16,Y+1
     357 940E 0BFD CALL	_angle
(0207) 		angle(dir5, MOTOR_B, lift);
     359 8368      STD	Y+0,R22
     35A E422      LDI	R18,0x42
     35B 810A      LDD	R16,Y+2
     35C 940E 0BFD CALL	_angle
(0208) 		angle(dir1, MOTOR_C, 0);
     35E 2422      CLR	R2
     35F 8228      STD	Y+0,R2
     360 E423      LDI	R18,0x43
     361 8908      LDD	R16,Y+16
     362 940E 0BFD CALL	_angle
(0209) 		angle(dir3, MOTOR_C, 0);
     364 2422      CLR	R2
     365 8228      STD	Y+0,R2
     366 E423      LDI	R18,0x43
     367 8109      LDD	R16,Y+1
     368 940E 0BFD CALL	_angle
(0210) 		angle(dir5, MOTOR_C, 0);
     36A 2422      CLR	R2
     36B 8228      STD	Y+0,R2
     36C E423      LDI	R18,0x43
     36D 810A      LDD	R16,Y+2
     36E 940E 0BFD CALL	_angle
(0211) 		delay(delay_time);
     370 0186      MOVW	R16,R12
     371 940E 0BAA CALL	_delay
(0212) 
(0213) 		//moving the odd legs in air
(0214) 		angle(dir1, MOTOR_C, 180);
     373 EB84      LDI	R24,0xB4
     374 8388      STD	Y+0,R24
     375 E423      LDI	R18,0x43
     376 8908      LDD	R16,Y+16
     377 940E 0BFD CALL	_angle
(0215) 		angle(dir3, MOTOR_C, 180);
     379 EB84      LDI	R24,0xB4
     37A 8388      STD	Y+0,R24
     37B E423      LDI	R18,0x43
     37C 8109      LDD	R16,Y+1
     37D 940E 0BFD CALL	_angle
(0216) 		angle(dir5, MOTOR_C, 180);
     37F EB84      LDI	R24,0xB4
     380 8388      STD	Y+0,R24
     381 E423      LDI	R18,0x43
     382 810A      LDD	R16,Y+2
     383 940E 0BFD CALL	_angle
(0217) 		angle(dir1, MOTOR_A, 90 + step_forward);
     385 2F84      MOV	R24,R20
     386 5A86      SUBI	R24,0xA6
     387 8388      STD	Y+0,R24
     388 E421      LDI	R18,0x41
     389 8908      LDD	R16,Y+16
     38A 940E 0BFD CALL	_angle
(0218) 		angle(dir3, MOTOR_A, 90 - step_side);
     38C E58A      LDI	R24,0x5A
     38D 198E      SUB	R24,R14
     38E 8388      STD	Y+0,R24
     38F E421      LDI	R18,0x41
     390 8109      LDD	R16,Y+1
     391 940E 0BFD CALL	_angle
(0219) 		angle(dir5, MOTOR_A, 90 + step_side);
     393 2D8E      MOV	R24,R14
     394 5A86      SUBI	R24,0xA6
     395 8388      STD	Y+0,R24
     396 E421      LDI	R18,0x41
     397 810A      LDD	R16,Y+2
     398 940E 0BFD CALL	_angle
(0220) 		delay(delay_time);
     39A 0186      MOVW	R16,R12
     39B 940E 0BAA CALL	_delay
(0221) 		
(0222) 		//moving the body forward on even tripod
(0223) 		angle(dir2, MOTOR_A, 90);
     39D E58A      LDI	R24,0x5A
     39E 8388      STD	Y+0,R24
     39F E421      LDI	R18,0x41
     3A0 810B      LDD	R16,Y+3
     3A1 940E 0BFD CALL	_angle
(0224) 		angle(dir4, MOTOR_A, 90);
     3A3 E58A      LDI	R24,0x5A
     3A4 8388      STD	Y+0,R24
     3A5 E421      LDI	R18,0x41
     3A6 810C      LDD	R16,Y+4
     3A7 940E 0BFD CALL	_angle
(0225) 		angle(dir6, MOTOR_A, 90);
     3A9 E58A      LDI	R24,0x5A
     3AA 8388      STD	Y+0,R24
     3AB E421      LDI	R18,0x41
     3AC 810D      LDD	R16,Y+5
     3AD 940E 0BFD CALL	_angle
(0226) 		delay(delay_time);
     3AF 0186      MOVW	R16,R12
     3B0 940E 0BAA CALL	_delay
     3B2 882A      LDD	R2,Y+18
     3B3 2433      CLR	R3
     3B4 2D82      MOV	R24,R2
     3B5 5081      SUBI	R24,1
     3B6 8B8A      STD	Y+18,R24
     3B7 E080      LDI	R24,0
     3B8 1582      CP	R24,R2
     3B9 F408      BCC	0x03BB
     3BA CEE3      RJMP	0x029E
     3BB 9626      ADIW	R28,6
     3BC 940E 13AF CALL	pop_xgsetF0FC
     3BE 9624      ADIW	R28,4
     3BF 9508      RET
_two_leg_gait:
  legs_clock           --> Y,+8
  legs_anticlock       --> Y,+1
  delay_time2          --> R10
  delay_time1          --> R14
  step_side            --> R12
  dir6                 --> Y,+18
  dir5                 --> Y,+17
  dir4                 --> Y,+16
  dir3                 --> Y,+15
  lift                 --> R22
  step_forward         --> R20
  steps                --> Y,+33
  dir2                 --> Y,+31
  dir1                 --> Y,+29
     3C0 940E 1379 CALL	push_arg4
     3C2 940E 13BA CALL	push_xgsetF0FC
     3C4 9763      SBIW	R28,0x13
(0227) 	}
(0228) }
(0229) 
(0230) /**
(0231) Two leg gait in which two legs are moved at a time
(0232) @param dir1 : Direction of motion
(0233) @param dir2 : Direction of motion
(0234) @param steps : number of steps
(0235) */
(0236) void two_leg_gait(unsigned char dir1, unsigned char dir2, int steps) {
(0237) 	 unsigned char legs_anticlock[] = {0,2,3,6,1,4,5};
     3C5 E382      LDI	R24,0x32
     3C6 E091      LDI	R25,1
     3C7 01FE      MOVW	R30,R28
     3C8 9631      ADIW	R30,1
     3C9 E007      LDI	R16,7
     3CA E010      LDI	R17,0
     3CB 93FA      ST	R31,-Y
     3CC 93EA      ST	R30,-Y
     3CD 939A      ST	R25,-Y
     3CE 938A      ST	R24,-Y
     3CF 940E 13EF CALL	asgncblkx
(0238) 	 unsigned char legs_clock[] = {0,4,1,2,5,6,3}; 
     3D1 E389      LDI	R24,0x39
     3D2 E091      LDI	R25,1
     3D3 01FE      MOVW	R30,R28
     3D4 9638      ADIW	R30,0x8
     3D5 E007      LDI	R16,7
     3D6 E010      LDI	R17,0
     3D7 93FA      ST	R31,-Y
     3D8 93EA      ST	R30,-Y
     3D9 939A      ST	R25,-Y
     3DA 938A      ST	R24,-Y
     3DB 940E 13EF CALL	asgncblkx
(0239) 	 unsigned char dir3 = legs_anticlock[dir2];
     3DD 01CE      MOVW	R24,R28
     3DE 9601      ADIW	R24,1
     3DF 8DEF      LDD	R30,Y+31
     3E0 27FF      CLR	R31
     3E1 0FE8      ADD	R30,R24
     3E2 1FF9      ADC	R31,R25
     3E3 8020      LDD	R2,Z+0
     3E4 862F      STD	Y+15,R2
(0240) 	 unsigned char dir4 = legs_clock[dir1];
     3E5 01CE      MOVW	R24,R28
     3E6 9608      ADIW	R24,0x8
     3E7 8DED      LDD	R30,Y+29
     3E8 27FF      CLR	R31
     3E9 0FE8      ADD	R30,R24
     3EA 1FF9      ADC	R31,R25
     3EB 8020      LDD	R2,Z+0
     3EC 8A28      STD	Y+16,R2
(0241) 	 unsigned char dir5 = legs_clock[dir4];
     3ED 01CE      MOVW	R24,R28
     3EE 9608      ADIW	R24,0x8
     3EF 2DE2      MOV	R30,R2
     3F0 27FF      CLR	R31
     3F1 0FE8      ADD	R30,R24
     3F2 1FF9      ADC	R31,R25
     3F3 8020      LDD	R2,Z+0
     3F4 8A29      STD	Y+17,R2
(0242) 	 unsigned char dir6= legs_anticlock[dir3];
     3F5 01CE      MOVW	R24,R28
     3F6 9601      ADIW	R24,1
     3F7 85EF      LDD	R30,Y+15
     3F8 27FF      CLR	R31
     3F9 0FE8      ADD	R30,R24
     3FA 1FF9      ADC	R31,R25
     3FB 8020      LDD	R2,Z+0
     3FC 8A2A      STD	Y+18,R2
(0243) 	 unsigned char step_forward = 50;
     3FD E342      LDI	R20,0x32
(0244) 	 unsigned char step_side = 40;
     3FE E288      LDI	R24,0x28
     3FF 2EC8      MOV	R12,R24
(0245) 	 unsigned char lift = 40;
     400 E268      LDI	R22,0x28
(0246) 	 int delay_time1 = FIVE_HUNDRED_MSEC;
     401 EC88      LDI	R24,0xC8
     402 E090      LDI	R25,0
     403 017C      MOVW	R14,R24
(0247) 	 int delay_time2 = FIVE_HUNDRED_MSEC;
     404 015C      MOVW	R10,R24
     405 C0A8      RJMP	0x04AE
(0248) 	 
(0249) 	 while(steps-- > 0) {
(0250) 	 
(0251) 	    //putting down legs 5 & 6
(0252) 		angle(dir5, MOTOR_B, 90);
     406 E58A      LDI	R24,0x5A
     407 8388      STD	Y+0,R24
     408 E422      LDI	R18,0x42
     409 8909      LDD	R16,Y+17
     40A 940E 0BFD CALL	_angle
(0253) 		angle(dir6, MOTOR_B, 90);
     40C E58A      LDI	R24,0x5A
     40D 8388      STD	Y+0,R24
     40E E422      LDI	R18,0x42
     40F 890A      LDD	R16,Y+18
     410 940E 0BFD CALL	_angle
(0254) 	 
(0255) 	 	//picking up 1 & 2 legs
(0256) 		angle(dir1, MOTOR_B, lift);
     412 8368      STD	Y+0,R22
     413 E422      LDI	R18,0x42
     414 8D0D      LDD	R16,Y+29
     415 940E 0BFD CALL	_angle
(0257) 		angle(dir2, MOTOR_B, lift);
     417 8368      STD	Y+0,R22
     418 E422      LDI	R18,0x42
     419 8D0F      LDD	R16,Y+31
     41A 940E 0BFD CALL	_angle
(0258) 		
(0259) 		//delay
(0260) 		delay(delay_time1);
     41C 0187      MOVW	R16,R14
     41D 940E 0BAA CALL	_delay
(0261) 		
(0262) 		//moving body on legs 5 & 6
(0263) 		angle(dir5, MOTOR_A, 90 - step_forward);
     41F E58A      LDI	R24,0x5A
     420 1B84      SUB	R24,R20
     421 8388      STD	Y+0,R24
     422 E421      LDI	R18,0x41
     423 8909      LDD	R16,Y+17
     424 940E 0BFD CALL	_angle
(0264) 		angle(dir6, MOTOR_A, 90 + step_forward);
     426 2F84      MOV	R24,R20
     427 5A86      SUBI	R24,0xA6
     428 8388      STD	Y+0,R24
     429 E421      LDI	R18,0x41
     42A 890A      LDD	R16,Y+18
     42B 940E 0BFD CALL	_angle
(0265) 		
(0266) 		//moving 1 & 2 legs in air 
(0267) 		angle(dir1, MOTOR_A, 90 + step_forward);
     42D 2F84      MOV	R24,R20
     42E 5A86      SUBI	R24,0xA6
     42F 8388      STD	Y+0,R24
     430 E421      LDI	R18,0x41
     431 8D0D      LDD	R16,Y+29
     432 940E 0BFD CALL	_angle
(0268) 		angle(dir2, MOTOR_A, 90 - step_forward);
     434 E58A      LDI	R24,0x5A
     435 1B84      SUB	R24,R20
     436 8388      STD	Y+0,R24
     437 E421      LDI	R18,0x41
     438 8D0F      LDD	R16,Y+31
     439 940E 0BFD CALL	_angle
(0269) 		
(0270) 		//delay
(0271) 		delay(delay_time1);
     43B 0187      MOVW	R16,R14
     43C 940E 0BAA CALL	_delay
(0272) 		
(0273) 		//putting 1 & 2 legs down
(0274) 		angle(dir1, MOTOR_B, 90);
     43E E58A      LDI	R24,0x5A
     43F 8388      STD	Y+0,R24
     440 E422      LDI	R18,0x42
     441 8D0D      LDD	R16,Y+29
     442 940E 0BFD CALL	_angle
(0275) 		angle(dir2, MOTOR_B, 90);
     444 E58A      LDI	R24,0x5A
     445 8388      STD	Y+0,R24
     446 E422      LDI	R18,0x42
     447 8D0F      LDD	R16,Y+31
     448 940E 0BFD CALL	_angle
(0276) 		
(0277) 		//picking up 3 & 4 legs		   
(0278) 	 	angle(dir3, MOTOR_B, lift);
     44A 8368      STD	Y+0,R22
     44B E422      LDI	R18,0x42
     44C 850F      LDD	R16,Y+15
     44D 940E 0BFD CALL	_angle
(0279) 		angle(dir4, MOTOR_B, lift);
     44F 8368      STD	Y+0,R22
     450 E422      LDI	R18,0x42
     451 8908      LDD	R16,Y+16
     452 940E 0BFD CALL	_angle
(0280) 		
(0281) 		delay(delay_time1);
     454 0187      MOVW	R16,R14
     455 940E 0BAA CALL	_delay
(0282) 		
(0283) 		//moving body on legs 1 & 2
(0284) 		angle(dir1, MOTOR_A, 90 - step_forward);
     457 E58A      LDI	R24,0x5A
     458 1B84      SUB	R24,R20
     459 8388      STD	Y+0,R24
     45A E421      LDI	R18,0x41
     45B 8D0D      LDD	R16,Y+29
     45C 940E 0BFD CALL	_angle
(0285) 		angle(dir2, MOTOR_A, 90 + step_forward);
     45E 2F84      MOV	R24,R20
     45F 5A86      SUBI	R24,0xA6
     460 8388      STD	Y+0,R24
     461 E421      LDI	R18,0x41
     462 8D0F      LDD	R16,Y+31
     463 940E 0BFD CALL	_angle
(0286) 		
(0287) 		//moving legs 3 & 4 in air
(0288) 		angle(dir3, MOTOR_A, 90 - step_side);
     465 E58A      LDI	R24,0x5A
     466 198C      SUB	R24,R12
     467 8388      STD	Y+0,R24
     468 E421      LDI	R18,0x41
     469 850F      LDD	R16,Y+15
     46A 940E 0BFD CALL	_angle
(0289) 		angle(dir4, MOTOR_A, 90 + step_side);
     46C 2D8C      MOV	R24,R12
     46D 5A86      SUBI	R24,0xA6
     46E 8388      STD	Y+0,R24
     46F E421      LDI	R18,0x41
     470 8908      LDD	R16,Y+16
     471 940E 0BFD CALL	_angle
(0290) 		
(0291) 		delay(delay_time2);
     473 0185      MOVW	R16,R10
     474 940E 0BAA CALL	_delay
(0292) 		
(0293) 		//putting down legs 3 & 4
(0294) 		angle(dir3, MOTOR_B, 90);
     476 E58A      LDI	R24,0x5A
     477 8388      STD	Y+0,R24
     478 E422      LDI	R18,0x42
     479 850F      LDD	R16,Y+15
     47A 940E 0BFD CALL	_angle
(0295) 		angle(dir4, MOTOR_B, 90);
     47C E58A      LDI	R24,0x5A
     47D 8388      STD	Y+0,R24
     47E E422      LDI	R18,0x42
     47F 8908      LDD	R16,Y+16
     480 940E 0BFD CALL	_angle
(0296) 		
(0297) 		//picking up legs 5 & 6
(0298) 		angle(dir5, MOTOR_B, lift);
     482 8368      STD	Y+0,R22
     483 E422      LDI	R18,0x42
     484 8909      LDD	R16,Y+17
     485 940E 0BFD CALL	_angle
(0299) 		angle(dir6, MOTOR_B, lift);
     487 8368      STD	Y+0,R22
     488 E422      LDI	R18,0x42
     489 890A      LDD	R16,Y+18
     48A 940E 0BFD CALL	_angle
(0300) 		
(0301) 		delay(delay_time1);
     48C 0187      MOVW	R16,R14
     48D 940E 0BAA CALL	_delay
(0302) 		
(0303) 		//moving body on legs 3 & 4
(0304) 		angle(dir3, MOTOR_A, 90 + step_side);
     48F 2D8C      MOV	R24,R12
     490 5A86      SUBI	R24,0xA6
     491 8388      STD	Y+0,R24
     492 E421      LDI	R18,0x41
     493 850F      LDD	R16,Y+15
     494 940E 0BFD CALL	_angle
(0305) 		angle(dir4, MOTOR_A, 90 - step_side);
     496 E58A      LDI	R24,0x5A
     497 198C      SUB	R24,R12
     498 8388      STD	Y+0,R24
     499 E421      LDI	R18,0x41
     49A 8908      LDD	R16,Y+16
     49B 940E 0BFD CALL	_angle
(0306) 		
(0307) 		//moving legs 5 & 6 in air 
(0308) 		angle(dir5, MOTOR_A, 90 + step_forward);
     49D 2F84      MOV	R24,R20
     49E 5A86      SUBI	R24,0xA6
     49F 8388      STD	Y+0,R24
     4A0 E421      LDI	R18,0x41
     4A1 8909      LDD	R16,Y+17
     4A2 940E 0BFD CALL	_angle
(0309) 		angle(dir6, MOTOR_A, 90 - step_forward);
     4A4 E58A      LDI	R24,0x5A
     4A5 1B84      SUB	R24,R20
     4A6 8388      STD	Y+0,R24
     4A7 E421      LDI	R18,0x41
     4A8 890A      LDD	R16,Y+18
     4A9 940E 0BFD CALL	_angle
(0310) 		
(0311) 		delay(delay_time2);
     4AB 0185      MOVW	R16,R10
     4AC 940E 0BAA CALL	_delay
     4AE A049      LDD	R4,Y+33
     4AF A05A      LDD	R5,Y+34
     4B0 01C2      MOVW	R24,R4
     4B1 9701      SBIW	R24,1
     4B2 A39A      STD	Y+34,R25
     4B3 A389      STD	Y+33,R24
     4B4 2422      CLR	R2
     4B5 2433      CLR	R3
     4B6 1424      CP	R2,R4
     4B7 0435      CPC	R3,R5
     4B8 F40C      BGE	0x04BA
     4B9 CF4C      RJMP	0x0406
     4BA 9663      ADIW	R28,0x13
     4BB 940E 13AF CALL	pop_xgsetF0FC
     4BD 9624      ADIW	R28,4
     4BE 9508      RET
FILE: D:\BUILDI~1\hexapod.c
(0001) //ICC-AVR application builder : 11/4/2009 1:05:10 PM
(0002) // Target : M2560
(0003) // Crystal: 11.059Mhz
(0004) 
(0005) /*
(0006)  Pin name	Port		Anding (make 0)		Oring (make 1)
(0007)  SP LEFT	PL1		1111 1101	0xFD		0000 0010	0x02
(0008) 
(0009)  1A		PD5		1101 1111	0xDF		0010 0000	0x20
(0010)  1B		PL2		1111 1011	0xFB		0000 0100	0x04
(0011)  1C		PG1		1111 1101	0xFD		0000 0010	0x02
(0012)  2A		PL6		1011 1111	0xBF		0100 0000	0x40
(0013)  2B		PD4		1110 1111	0xEF		0001 0000	0x10
(0014)  2C		PL7		0111 1111	0x7F		1000 0000	0x80
(0015)  3A		PH6		1011 1111	0xBF		0100 0000	0x40
(0016)  3B		PH4		1110 1111	0xEF		0001 0000	0x10
(0017)  3C		PH5		1101 1111	0xDF		0010 0000	0x20
(0018)  SP RIGHT	PJ7		0111 1111	0x7F		1000 0000	0x80
(0019)  4A		PG0		1111 1110	0xFE		0000 0001	0x01
(0020)  4B		PD7		0111 1111	0x7F		1000 0000	0x80
(0021)  4C		PD6		1011 1111	0xBF		0100 0000	0x40
(0022)  5A		PJ5		1101 1111	0xDF		0010 0000	0x20
(0023)  5B		PJ6		1011 1111	0xBF		0100 0000	0x40
(0024)  5C		PJ4		1110 1111	0xEF		0001 0000	0x10
(0025)  6A		PJ3		1111 0111	0XF7		0000 1000	0x08
(0026)  6B		PJ1		1111 1101	0xFD		0000 0010	0x02
(0027)  6C		PJ2		1111 1011	0xFB		0000 0100	0x04
(0028) 
(0029)  Remote control communication protocoal
(0030)  transmitted command		received data
(0031)  1						right joystick x axis 8 bit analog position;	center:0x24; left: 0x3B; right: 0x04
(0032)  2						right joystick y axis 8 bit analog position;	center:0x24; up: 0x3B; down: 0x04
(0033)  3						left joystick x axis 8 bit analog position;		center:0x3A; left: 0x23; right: 0x04
(0034)  4						left joystick y axis 8 bit analog position;		center:0x1F; up: 0x34; down: 0x04
(0035)  5						right joystick button
(0036)  6						left joystick button
(0037)  7						digital switches left 1,2 and right 1,2
(0038)  bit7: Right 2; bit6: right 1; bit4: left 1; bit3: left 2
(0039) 
(0040)  Received data will be stored in the array unsigned char remote_data [8]; from the location 1 to 7 in the same order as the command.
(0041)  */
(0042)  
(0043)  
(0044)  /*********************************************************************************
(0045) 
(0046)    Copyright (c) 2010, ERTS Lab IIT Bombay erts@cse.iitb.ac.in               -*- c -*-
(0047)    All rights reserved.
(0048) 
(0049)    Redistribution and use in source and binary forms, with or without
(0050)    modification, are permitted provided that the following conditions are met:
(0051) 
(0052)    * Redistributions of source code must retain the above copyright
(0053)      notice, this list of conditions and the following disclaimer.
(0054) 
(0055)    * Redistributions in binary form must reproduce the above copyright
(0056)      notice, this list of conditions and the following disclaimer in
(0057)      the documentation and/or other materials provided with the
(0058)      distribution.
(0059) 
(0060)    * Neither the name of the copyright holders nor the names of
(0061)      contributors may be used to endorse or promote products derived
(0062)      from this software without specific prior written permission.
(0063) 
(0064)    * Source code can be used for academic purpose. 
(0065) 	 For commercial use permission form the author needs to be taken.
(0066) 
(0067)   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
(0068)   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
(0069)   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
(0070)   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
(0071)   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
(0072)   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
(0073)   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
(0074)   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
(0075)   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
(0076)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
(0077)   POSSIBILITY OF SUCH DAMAGE. 
(0078) 
(0079)   Software released under Creative Commence cc by-nc-sa licence.
(0080)   For legal information refer to: 
(0081)   http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode
(0082) 
(0083) ********************************************************************************/
(0084) 
(0085) 
(0086) #include <iom2560v.h>
(0087) #include <macros.h>
(0088) #include "hexapod_macro.h"
(0089) #include "keyboard.h"
(0090) 
(0091) 
(0092) unsigned char arm_number = 0;
(0093) unsigned char angle_upper_byte = 0;
(0094) unsigned char angle_lower_byte = 0;
(0095) unsigned char degree = 0;
(0096) unsigned char angle_upper_byte_1A, angle_lower_byte_1A;
(0097) angle_upper_byte_1B, angle_lower_byte_1B; angle_upper_byte_1C, angle_lower_byte_1C;
(0098) unsigned char angle_upper_byte_2A, angle_lower_byte_2A;
(0099) angle_upper_byte_2B, angle_lower_byte_2B; angle_upper_byte_2C, angle_lower_byte_2C;
(0100) unsigned char angle_upper_byte_3A, angle_lower_byte_3A;
(0101) angle_upper_byte_3B, angle_lower_byte_3B; angle_upper_byte_3C, angle_lower_byte_3C;
(0102) unsigned char angle_upper_byte_4A, angle_lower_byte_4A;
(0103) angle_upper_byte_4B, angle_lower_byte_4B; angle_upper_byte_4C, angle_lower_byte_4C;
(0104) unsigned char angle_upper_byte_5A, angle_lower_byte_5A;
(0105) angle_upper_byte_5B, angle_lower_byte_5B; angle_upper_byte_5C, angle_lower_byte_5C;
(0106) unsigned char angle_upper_byte_6A, angle_lower_byte_6A;
(0107) angle_upper_byte_6B, angle_lower_byte_6B; angle_upper_byte_6C, angle_lower_byte_6C;
(0108) unsigned int delay_count = 0;
(0109) //variables relatd to the serial commuication or remote control
(0110) unsigned int serial_communication_interval = 0;
(0111) unsigned char serial_communication_channel_number = 0;
(0112) unsigned char remote_data[8]; //see remote channel allocation in the notes above
(0113) unsigned char motion_busy = 0; //sets to one if any of the motion function is called.
(0114) 
(0115) unsigned char data;
(0116) 
(0117) 
(0118) 
(0119) void delay(int time);
(0120) void swap(unsigned char *a, unsigned char *b);
(0121) void buzzer_on(void);
(0122) void buzzer_off(void);
(0123) 
(0124) /**
(0125) Port Initialization
(0126) */
(0127) void port_init(void) {
(0128) 	PORTA = 0x00;
_port_init:
     4BF 2422      CLR	R2
     4C0 B822      OUT	0x02,R2
(0129) 	DDRA = 0xFF;
     4C1 EF8F      LDI	R24,0xFF
     4C2 B981      OUT	0x01,R24
(0130) 	PORTB = 0x00;
     4C3 B825      OUT	0x05,R2
(0131) 	DDRB = 0x01;
     4C4 E081      LDI	R24,1
     4C5 B984      OUT	0x04,R24
(0132) 	PORTC = 0x00; //m103 output only
     4C6 B828      OUT	0x08,R2
(0133) 	DDRC = 0xFF;
     4C7 EF8F      LDI	R24,0xFF
     4C8 B987      OUT	0x07,R24
(0134) 	PORTD = 0x00;
     4C9 B82B      OUT	0x0B,R2
(0135) 	DDRD = 0xF0;
     4CA EF80      LDI	R24,0xF0
     4CB B98A      OUT	0x0A,R24
(0136) 	PORTE = 0x00;
     4CC B82E      OUT	0x0E,R2
(0137) 	DDRE = 0x00;
     4CD B82D      OUT	0x0D,R2
(0138) 	PORTF = 0x00;
     4CE BA21      OUT	0x11,R2
(0139) 	DDRF = 0x00;
     4CF BA20      OUT	0x10,R2
(0140) 	PORTG = 0x00;
     4D0 BA24      OUT	0x14,R2
(0141) 	DDRG = 0x03;
     4D1 E083      LDI	R24,3
     4D2 BB83      OUT	0x13,R24
(0142) 	PORTH = 0x00;
     4D3 9220 0102 STS	0x0102,R2
(0143) 	DDRH = 0x70;
     4D5 E780      LDI	R24,0x70
     4D6 9380 0101 STS	0x0101,R24
(0144) 	PORTJ = 0x00;
     4D8 9220 0105 STS	0x0105,R2
(0145) 	DDRJ = 0xFE; //0xFE original
     4DA EF8E      LDI	R24,0xFE
     4DB 9380 0104 STS	0x0104,R24
(0146) 	PORTK = 0x00;
     4DD 9220 0108 STS	0x0108,R2
(0147) 	DDRK = 0x00;
     4DF 9220 0107 STS	0x0107,R2
(0148) 	PORTL = 0x00;
     4E1 9220 010B STS	0x010B,R2
(0149) 	DDRL = 0xC7;
     4E3 EC87      LDI	R24,0xC7
     4E4 9380 010A STS	0x010A,R24
     4E6 9508      RET
(0150) }
(0151) 
(0152) //TIMER1 initialize - prescale:1
(0153) // WGM: 0) Normal, TOP=0xFFFF
(0154) // desired value: 400Hz
(0155) // actual value: 400.007Hz (0.0%)
(0156) void timer1_init(void) {
(0157) 	TCCR1B = 0x00; //stop
_timer1_init:
     4E7 2422      CLR	R2
     4E8 9220 0081 STS	0x0081,R2
(0158) 	TCNT1H = 0x94; //setup
     4EA E984      LDI	R24,0x94
     4EB 9380 0085 STS	0x0085,R24
(0159) 	TCNT1L = 0x01;
     4ED E081      LDI	R24,1
     4EE 9380 0084 STS	0x0084,R24
(0160) 	OCR1AH = 0x6B;
     4F0 E68B      LDI	R24,0x6B
     4F1 9380 0089 STS	0x0089,R24
(0161) 	OCR1AL = 0xFF;
     4F3 EF8F      LDI	R24,0xFF
     4F4 9380 0088 STS	0x0088,R24
(0162) 	OCR1BH = 0x6B;
     4F6 E68B      LDI	R24,0x6B
     4F7 9380 008B STS	0x008B,R24
(0163) 	OCR1BL = 0xFF;
     4F9 EF8F      LDI	R24,0xFF
     4FA 9380 008A STS	0x008A,R24
(0164) 	OCR1CH = 0x00;
     4FC 9220 008D STS	0x008D,R2
(0165) 	OCR1CL = 0x00;
     4FE 9220 008C STS	0x008C,R2
(0166) 	ICR1H = 0x6B;
     500 E68B      LDI	R24,0x6B
     501 9380 0087 STS	0x0087,R24
(0167) 	ICR1L = 0xFF;
     503 EF8F      LDI	R24,0xFF
     504 9380 0086 STS	0x0086,R24
(0168) 	TCCR1A = 0x00;
     506 9220 0080 STS	0x0080,R2
(0169) 	TCCR1C = 0x00;
     508 9220 0082 STS	0x0082,R2
(0170) 	TCCR1B = 0x01; //start Timer
     50A E081      LDI	R24,1
     50B 9380 0081 STS	0x0081,R24
     50D 9508      RET
(0171) }
(0172) 
(0173) 
(0174) void turn_on_sharp15 (void) //turn on Sharp IR range sensors 1,5
(0175) {
(0176)   PORTH = PORTH & 0xFB;
_turn_on_sharp15:
     50E 9180 0102 LDS	R24,0x0102
     510 7F8B      ANDI	R24,0xFB
     511 9380 0102 STS	0x0102,R24
     513 9508      RET
(0177) }
(0178) 
(0179) void turn_off_sharp15 (void) //turn off Sharp IR range sensors 1,5
(0180) {
(0181)  PORTH = PORTH | 0x04;
_turn_off_sharp15:
     514 9180 0102 LDS	R24,0x0102
     516 6084      ORI	R24,4
     517 9380 0102 STS	0x0102,R24
     519 9508      RET
(0182) }
(0183) 
(0184) void reset_1A(void) {
(0185) 	PORTD = PORTD & 0xDF;
_reset_1A:
     51A B18B      IN	R24,0x0B
     51B 7D8F      ANDI	R24,0xDF
     51C B98B      OUT	0x0B,R24
     51D 9508      RET
(0186) }
(0187) 
(0188) void set_1A(void) {
(0189) 	PORTD = PORTD | 0x20;
_set_1A:
     51E 9A5D      SBI	0x0B,5
     51F 9508      RET
(0190) }
(0191) 
(0192) void reset_1B(void) {
(0193) 	PORTL = PORTL & 0xFB;
_reset_1B:
     520 9180 010B LDS	R24,0x010B
     522 7F8B      ANDI	R24,0xFB
     523 9380 010B STS	0x010B,R24
     525 9508      RET
(0194) }
(0195) 
(0196) void set_1B(void) {
(0197) 	PORTL = PORTL | 0x04;
_set_1B:
     526 9180 010B LDS	R24,0x010B
     528 6084      ORI	R24,4
     529 9380 010B STS	0x010B,R24
     52B 9508      RET
(0198) }
(0199) 
(0200) void reset_1C(void) {
(0201) 	PORTG = PORTG & 0xFD;
_reset_1C:
     52C B384      IN	R24,0x14
     52D 7F8D      ANDI	R24,0xFD
     52E BB84      OUT	0x14,R24
     52F 9508      RET
(0202) }
(0203) 
(0204) void set_1C(void) {
(0205) 	PORTG = PORTG | 0x02;
_set_1C:
     530 9AA1      SBI	0x14,1
     531 9508      RET
(0206) }
(0207) 
(0208) void reset_2A(void) {
(0209) 	PORTL = PORTL & 0xBF;
_reset_2A:
     532 9180 010B LDS	R24,0x010B
     534 7B8F      ANDI	R24,0xBF
     535 9380 010B STS	0x010B,R24
     537 9508      RET
(0210) }
(0211) 
(0212) void set_2A(void) {
(0213) 	PORTL = PORTL | 0x40;
_set_2A:
     538 9180 010B LDS	R24,0x010B
     53A 6480      ORI	R24,0x40
     53B 9380 010B STS	0x010B,R24
     53D 9508      RET
(0214) }
(0215) 
(0216) void reset_2B(void) {
(0217) 	PORTD = PORTD & 0xEF;
_reset_2B:
     53E B18B      IN	R24,0x0B
     53F 7E8F      ANDI	R24,0xEF
     540 B98B      OUT	0x0B,R24
     541 9508      RET
(0218) }
(0219) 
(0220) void set_2B(void) {
(0221) 	PORTD = PORTD | 0x10;
_set_2B:
     542 9A5C      SBI	0x0B,4
     543 9508      RET
(0222) }
(0223) 
(0224) void reset_2C(void) {
(0225) 	PORTL = PORTL & 0x7F;
_reset_2C:
     544 9180 010B LDS	R24,0x010B
     546 778F      ANDI	R24,0x7F
     547 9380 010B STS	0x010B,R24
     549 9508      RET
(0226) }
(0227) 
(0228) void set_2C(void) {
(0229) 	PORTL = PORTL | 0x80;
_set_2C:
     54A 9180 010B LDS	R24,0x010B
     54C 6880      ORI	R24,0x80
     54D 9380 010B STS	0x010B,R24
     54F 9508      RET
(0230) }
(0231) 
(0232) void reset_3A(void) {
(0233) 	PORTH = PORTH & 0xBF;
_reset_3A:
     550 9180 0102 LDS	R24,0x0102
     552 7B8F      ANDI	R24,0xBF
     553 9380 0102 STS	0x0102,R24
     555 9508      RET
(0234) }
(0235) 
(0236) void set_3A(void) {
(0237) 	PORTH = PORTH | 0x40;
_set_3A:
     556 9180 0102 LDS	R24,0x0102
     558 6480      ORI	R24,0x40
     559 9380 0102 STS	0x0102,R24
     55B 9508      RET
(0238) }
(0239) 
(0240) void reset_3B(void) {
(0241) 	PORTH = PORTH & 0xEF;
_reset_3B:
     55C 9180 0102 LDS	R24,0x0102
     55E 7E8F      ANDI	R24,0xEF
     55F 9380 0102 STS	0x0102,R24
     561 9508      RET
(0242) }
(0243) 
(0244) void set_3B(void) {
(0245) 	PORTH = PORTH | 0x10;
_set_3B:
     562 9180 0102 LDS	R24,0x0102
     564 6180      ORI	R24,0x10
     565 9380 0102 STS	0x0102,R24
     567 9508      RET
(0246) }
(0247) 
(0248) void reset_3C(void) {
(0249) 	PORTH = PORTH & 0xDF;
_reset_3C:
     568 9180 0102 LDS	R24,0x0102
     56A 7D8F      ANDI	R24,0xDF
     56B 9380 0102 STS	0x0102,R24
     56D 9508      RET
(0250) }
(0251) 
(0252) void set_3C(void) {
(0253) 	PORTH = PORTH | 0x20;
_set_3C:
     56E 9180 0102 LDS	R24,0x0102
     570 6280      ORI	R24,0x20
     571 9380 0102 STS	0x0102,R24
     573 9508      RET
(0254) }
(0255) 
(0256) void reset_SP_RIGHT(void) {
(0257) 	PORTJ = PORTJ & 0x7F;
_reset_SP_RIGHT:
     574 9180 0105 LDS	R24,0x0105
     576 778F      ANDI	R24,0x7F
     577 9380 0105 STS	0x0105,R24
     579 9508      RET
(0258) }
(0259) 
(0260) void set_SP_RIGHT(void) {
(0261) 	PORTJ = PORTJ | 0x80;
_set_SP_RIGHT:
     57A 9180 0105 LDS	R24,0x0105
     57C 6880      ORI	R24,0x80
     57D 9380 0105 STS	0x0105,R24
     57F 9508      RET
(0262) }
(0263) 
(0264) void reset_4A(void) {
(0265) 	PORTG = PORTG & 0xFE;
_reset_4A:
     580 B384      IN	R24,0x14
     581 7F8E      ANDI	R24,0xFE
     582 BB84      OUT	0x14,R24
     583 9508      RET
(0266) }
(0267) 
(0268) void set_4A(void) {
(0269) 	PORTG = PORTG | 0x01;
_set_4A:
     584 9AA0      SBI	0x14,0
     585 9508      RET
(0270) }
(0271) 
(0272) void reset_4B(void) {
(0273) 	PORTD = PORTD & 0x7F;
_reset_4B:
     586 B18B      IN	R24,0x0B
     587 778F      ANDI	R24,0x7F
     588 B98B      OUT	0x0B,R24
     589 9508      RET
(0274) }
(0275) 
(0276) void set_4B(void) {
(0277) 	PORTD = PORTD | 0x80;
_set_4B:
     58A 9A5F      SBI	0x0B,7
     58B 9508      RET
(0278) }
(0279) 
(0280) void reset_4C(void) {
(0281) 	PORTD = PORTD & 0xBF;
_reset_4C:
     58C B18B      IN	R24,0x0B
     58D 7B8F      ANDI	R24,0xBF
     58E B98B      OUT	0x0B,R24
     58F 9508      RET
(0282) }
(0283) 
(0284) void set_4C(void) {
(0285) 	PORTD = PORTD | 0x40;
_set_4C:
     590 9A5E      SBI	0x0B,6
     591 9508      RET
(0286) }
(0287) 
(0288) void reset_5A(void) {
(0289) 	PORTJ = PORTJ & 0xDF;
_reset_5A:
     592 9180 0105 LDS	R24,0x0105
     594 7D8F      ANDI	R24,0xDF
     595 9380 0105 STS	0x0105,R24
     597 9508      RET
(0290) }
(0291) 
(0292) void set_5A(void) {
(0293) 	PORTJ = PORTJ | 0x20;
_set_5A:
     598 9180 0105 LDS	R24,0x0105
     59A 6280      ORI	R24,0x20
     59B 9380 0105 STS	0x0105,R24
     59D 9508      RET
(0294) }
(0295) 
(0296) void reset_5B(void) {
(0297) 	PORTJ = PORTJ & 0xBF;
_reset_5B:
     59E 9180 0105 LDS	R24,0x0105
     5A0 7B8F      ANDI	R24,0xBF
     5A1 9380 0105 STS	0x0105,R24
     5A3 9508      RET
(0298) }
(0299) 
(0300) void set_5B(void) {
(0301) 	PORTJ = PORTJ | 0x40;
_set_5B:
     5A4 9180 0105 LDS	R24,0x0105
     5A6 6480      ORI	R24,0x40
     5A7 9380 0105 STS	0x0105,R24
     5A9 9508      RET
(0302) }
(0303) 
(0304) void reset_5C(void) {
(0305) 	PORTJ = PORTJ & 0xEF;
_reset_5C:
     5AA 9180 0105 LDS	R24,0x0105
     5AC 7E8F      ANDI	R24,0xEF
     5AD 9380 0105 STS	0x0105,R24
     5AF 9508      RET
(0306) }
(0307) 
(0308) void set_5C(void) {
(0309) 	PORTJ = PORTJ | 0x10;
_set_5C:
     5B0 9180 0105 LDS	R24,0x0105
     5B2 6180      ORI	R24,0x10
     5B3 9380 0105 STS	0x0105,R24
     5B5 9508      RET
(0310) }
(0311) 
(0312) void reset_6A(void) {
(0313) 	PORTJ = PORTJ & 0xF7;
_reset_6A:
     5B6 9180 0105 LDS	R24,0x0105
     5B8 7F87      ANDI	R24,0xF7
     5B9 9380 0105 STS	0x0105,R24
     5BB 9508      RET
(0314) }
(0315) 
(0316) void set_6A(void) {
(0317) 	PORTJ = PORTJ | 0x08;
_set_6A:
     5BC 9180 0105 LDS	R24,0x0105
     5BE 6088      ORI	R24,0x8
     5BF 9380 0105 STS	0x0105,R24
     5C1 9508      RET
(0318) }
(0319) 
(0320) void reset_6B(void) {
(0321) 	PORTJ = PORTJ & 0xFD;
_reset_6B:
     5C2 9180 0105 LDS	R24,0x0105
     5C4 7F8D      ANDI	R24,0xFD
     5C5 9380 0105 STS	0x0105,R24
     5C7 9508      RET
(0322) }
(0323) 
(0324) void set_6B(void) {
(0325) 	PORTJ = PORTJ | 0x02;
_set_6B:
     5C8 9180 0105 LDS	R24,0x0105
     5CA 6082      ORI	R24,2
     5CB 9380 0105 STS	0x0105,R24
     5CD 9508      RET
(0326) }
(0327) 
(0328) void reset_6C(void) {
(0329) 	PORTJ = PORTJ & 0xFB;
_reset_6C:
     5CE 9180 0105 LDS	R24,0x0105
     5D0 7F8B      ANDI	R24,0xFB
     5D1 9380 0105 STS	0x0105,R24
     5D3 9508      RET
(0330) }
(0331) 
(0332) void set_6C(void) {
(0333) 	PORTJ = PORTJ | 0x04;
_set_6C:
     5D4 9180 0105 LDS	R24,0x0105
     5D6 6084      ORI	R24,4
     5D7 9380 0105 STS	0x0105,R24
     5D9 9508      RET
_timer1_compa_isr:
     5DA 920A      ST	R0,-Y
     5DB 921A      ST	R1,-Y
     5DC 922A      ST	R2,-Y
     5DD 923A      ST	R3,-Y
     5DE 924A      ST	R4,-Y
     5DF 925A      ST	R5,-Y
     5E0 926A      ST	R6,-Y
     5E1 927A      ST	R7,-Y
     5E2 928A      ST	R8,-Y
     5E3 929A      ST	R9,-Y
     5E4 930A      ST	R16,-Y
     5E5 931A      ST	R17,-Y
     5E6 932A      ST	R18,-Y
     5E7 933A      ST	R19,-Y
     5E8 938A      ST	R24,-Y
     5E9 939A      ST	R25,-Y
     5EA 93AA      ST	R26,-Y
     5EB 93BA      ST	R27,-Y
     5EC 93EA      ST	R30,-Y
     5ED 93FA      ST	R31,-Y
     5EE B60F      IN	R0,0x3F
     5EF 920A      ST	R0,-Y
(0334) }
(0335) 
(0336) 
(0337) #pragma interrupt_handler timer1_compa_isr:iv_TIM1_COMPA
(0338) void timer1_compa_isr(void) {
(0339) 	//compare occured TCNT1=OCR1A
(0340) 	if (arm_number == 0) {
     5F0 9020 0200 LDS	R2,arm_number
     5F2 2022      TST	R2
     5F3 F409      BNE	0x05F5
(0341) 		reset_1A();
     5F4 DF25      RCALL	_reset_1A
(0342) 	}
(0343) 	if (arm_number == 1) {
     5F5 9180 0200 LDS	R24,arm_number
     5F7 3081      CPI	R24,1
     5F8 F409      BNE	0x05FA
(0344) 		reset_2A();
     5F9 DF38      RCALL	_reset_2A
(0345) 	}
(0346) 	if (arm_number == 2) {
     5FA 9180 0200 LDS	R24,arm_number
     5FC 3082      CPI	R24,2
     5FD F409      BNE	0x05FF
(0347) 		reset_3A();
     5FE DF51      RCALL	_reset_3A
(0348) 	}
(0349) 	if (arm_number == 3) {
     5FF 9180 0200 LDS	R24,arm_number
     601 3083      CPI	R24,3
     602 F409      BNE	0x0604
(0350) 		reset_4A();
     603 DF7C      RCALL	_reset_4A
(0351) 	}
(0352) 	if (arm_number == 4) {
     604 9180 0200 LDS	R24,arm_number
     606 3084      CPI	R24,4
     607 F409      BNE	0x0609
(0353) 		reset_5A();
     608 DF89      RCALL	_reset_5A
(0354) 	}
(0355) 	if (arm_number == 5) {
     609 9180 0200 LDS	R24,arm_number
     60B 3085      CPI	R24,5
     60C F409      BNE	0x060E
(0356) 		reset_6A();
     60D DFA8      RCALL	_reset_6A
(0357) 	}
     60E 9009      LD	R0,Y+
     60F BE0F      OUT	0x3F,R0
     610 91F9      LD	R31,Y+
     611 91E9      LD	R30,Y+
     612 91B9      LD	R27,Y+
     613 91A9      LD	R26,Y+
     614 9199      LD	R25,Y+
     615 9189      LD	R24,Y+
     616 9139      LD	R19,Y+
     617 9129      LD	R18,Y+
     618 9119      LD	R17,Y+
     619 9109      LD	R16,Y+
     61A 9099      LD	R9,Y+
     61B 9089      LD	R8,Y+
     61C 9079      LD	R7,Y+
     61D 9069      LD	R6,Y+
     61E 9059      LD	R5,Y+
     61F 9049      LD	R4,Y+
     620 9039      LD	R3,Y+
     621 9029      LD	R2,Y+
     622 9019      LD	R1,Y+
     623 9009      LD	R0,Y+
     624 9518      RETI
_timer1_compb_isr:
     625 920A      ST	R0,-Y
     626 921A      ST	R1,-Y
     627 922A      ST	R2,-Y
     628 923A      ST	R3,-Y
     629 924A      ST	R4,-Y
     62A 925A      ST	R5,-Y
     62B 926A      ST	R6,-Y
     62C 927A      ST	R7,-Y
     62D 928A      ST	R8,-Y
     62E 929A      ST	R9,-Y
     62F 930A      ST	R16,-Y
     630 931A      ST	R17,-Y
     631 932A      ST	R18,-Y
     632 933A      ST	R19,-Y
     633 938A      ST	R24,-Y
     634 939A      ST	R25,-Y
     635 93AA      ST	R26,-Y
     636 93BA      ST	R27,-Y
     637 93EA      ST	R30,-Y
     638 93FA      ST	R31,-Y
     639 B60F      IN	R0,0x3F
     63A 920A      ST	R0,-Y
(0358) }
(0359) 
(0360) #pragma interrupt_handler timer1_compb_isr:iv_TIM1_COMPB
(0361) void timer1_compb_isr(void) {
(0362) 	//compare occured TCNT1=OCR1B
(0363) 	if (arm_number == 0) {
     63B 9020 0200 LDS	R2,arm_number
     63D 2022      TST	R2
     63E F409      BNE	0x0640
(0364) 		reset_1B();
     63F DEE0      RCALL	_reset_1B
(0365) 	}
(0366) 	if (arm_number == 1) {
     640 9180 0200 LDS	R24,arm_number
     642 3081      CPI	R24,1
     643 F409      BNE	0x0645
(0367) 		reset_2B();
     644 DEF9      RCALL	_reset_2B
(0368) 	}
(0369) 	if (arm_number == 2) {
     645 9180 0200 LDS	R24,arm_number
     647 3082      CPI	R24,2
     648 F409      BNE	0x064A
(0370) 		reset_3B();
     649 DF12      RCALL	_reset_3B
(0371) 	}
(0372) 	if (arm_number == 3) {
     64A 9180 0200 LDS	R24,arm_number
     64C 3083      CPI	R24,3
     64D F409      BNE	0x064F
(0373) 		reset_4B();
     64E DF37      RCALL	_reset_4B
(0374) 	}
(0375) 	if (arm_number == 4) {
     64F 9180 0200 LDS	R24,arm_number
     651 3084      CPI	R24,4
     652 F409      BNE	0x0654
(0376) 		reset_5B();
     653 DF4A      RCALL	_reset_5B
(0377) 	}
(0378) 	if (arm_number == 5) {
     654 9180 0200 LDS	R24,arm_number
     656 3085      CPI	R24,5
     657 F409      BNE	0x0659
(0379) 		reset_6B();
     658 DF69      RCALL	_reset_6B
(0380) 	}
     659 9009      LD	R0,Y+
     65A BE0F      OUT	0x3F,R0
     65B 91F9      LD	R31,Y+
     65C 91E9      LD	R30,Y+
     65D 91B9      LD	R27,Y+
     65E 91A9      LD	R26,Y+
     65F 9199      LD	R25,Y+
     660 9189      LD	R24,Y+
     661 9139      LD	R19,Y+
     662 9129      LD	R18,Y+
     663 9119      LD	R17,Y+
     664 9109      LD	R16,Y+
     665 9099      LD	R9,Y+
     666 9089      LD	R8,Y+
     667 9079      LD	R7,Y+
     668 9069      LD	R6,Y+
     669 9059      LD	R5,Y+
     66A 9049      LD	R4,Y+
     66B 9039      LD	R3,Y+
     66C 9029      LD	R2,Y+
     66D 9019      LD	R1,Y+
     66E 9009      LD	R0,Y+
     66F 9518      RETI
_timer1_compc_isr:
     670 920A      ST	R0,-Y
     671 921A      ST	R1,-Y
     672 922A      ST	R2,-Y
     673 923A      ST	R3,-Y
     674 924A      ST	R4,-Y
     675 925A      ST	R5,-Y
     676 926A      ST	R6,-Y
     677 927A      ST	R7,-Y
     678 928A      ST	R8,-Y
     679 929A      ST	R9,-Y
     67A 930A      ST	R16,-Y
     67B 931A      ST	R17,-Y
     67C 932A      ST	R18,-Y
     67D 933A      ST	R19,-Y
     67E 938A      ST	R24,-Y
     67F 939A      ST	R25,-Y
     680 93AA      ST	R26,-Y
     681 93BA      ST	R27,-Y
     682 93EA      ST	R30,-Y
     683 93FA      ST	R31,-Y
     684 B60F      IN	R0,0x3F
     685 920A      ST	R0,-Y
(0381) }
(0382) 
(0383) #pragma interrupt_handler timer1_compc_isr:iv_TIM1_COMPC
(0384) void timer1_compc_isr(void) {
(0385) 	//compare occured TCNT1=OCR1c
(0386) 	if (arm_number == 0) {
     686 9020 0200 LDS	R2,arm_number
     688 2022      TST	R2
     689 F409      BNE	0x068B
(0387) 		reset_1C();
     68A DEA1      RCALL	_reset_1C
(0388) 	}
(0389) 	if (arm_number == 1) {
     68B 9180 0200 LDS	R24,arm_number
     68D 3081      CPI	R24,1
     68E F409      BNE	0x0690
(0390) 		reset_2C();
     68F DEB4      RCALL	_reset_2C
(0391) 	}
(0392) 	if (arm_number == 2) {
     690 9180 0200 LDS	R24,arm_number
     692 3082      CPI	R24,2
     693 F409      BNE	0x0695
(0393) 		reset_3C();
     694 DED3      RCALL	_reset_3C
(0394) 	}
(0395) 	if (arm_number == 3) {
     695 9180 0200 LDS	R24,arm_number
     697 3083      CPI	R24,3
     698 F409      BNE	0x069A
(0396) 		reset_4C();
     699 DEF2      RCALL	_reset_4C
(0397) 	}
(0398) 	if (arm_number == 4) {
     69A 9180 0200 LDS	R24,arm_number
     69C 3084      CPI	R24,4
     69D F409      BNE	0x069F
(0399) 		reset_5C();
     69E DF0B      RCALL	_reset_5C
(0400) 	}
(0401) 	if (arm_number == 5) {
     69F 9180 0200 LDS	R24,arm_number
     6A1 3085      CPI	R24,5
     6A2 F409      BNE	0x06A4
(0402) 		reset_6C();
     6A3 DF2A      RCALL	_reset_6C
(0403) 	}
     6A4 9009      LD	R0,Y+
     6A5 BE0F      OUT	0x3F,R0
     6A6 91F9      LD	R31,Y+
     6A7 91E9      LD	R30,Y+
     6A8 91B9      LD	R27,Y+
     6A9 91A9      LD	R26,Y+
     6AA 9199      LD	R25,Y+
     6AB 9189      LD	R24,Y+
     6AC 9139      LD	R19,Y+
     6AD 9129      LD	R18,Y+
     6AE 9119      LD	R17,Y+
     6AF 9109      LD	R16,Y+
     6B0 9099      LD	R9,Y+
     6B1 9089      LD	R8,Y+
     6B2 9079      LD	R7,Y+
     6B3 9069      LD	R6,Y+
     6B4 9059      LD	R5,Y+
     6B5 9049      LD	R4,Y+
     6B6 9039      LD	R3,Y+
     6B7 9029      LD	R2,Y+
     6B8 9019      LD	R1,Y+
     6B9 9009      LD	R0,Y+
     6BA 9518      RETI
_timer1_ovf_isr:
     6BB 920A      ST	R0,-Y
     6BC 921A      ST	R1,-Y
     6BD 922A      ST	R2,-Y
     6BE 923A      ST	R3,-Y
     6BF 924A      ST	R4,-Y
     6C0 925A      ST	R5,-Y
     6C1 926A      ST	R6,-Y
     6C2 927A      ST	R7,-Y
     6C3 928A      ST	R8,-Y
     6C4 929A      ST	R9,-Y
     6C5 930A      ST	R16,-Y
     6C6 931A      ST	R17,-Y
     6C7 932A      ST	R18,-Y
     6C8 933A      ST	R19,-Y
     6C9 938A      ST	R24,-Y
     6CA 939A      ST	R25,-Y
     6CB 93AA      ST	R26,-Y
     6CC 93BA      ST	R27,-Y
     6CD 93EA      ST	R30,-Y
     6CE 93FA      ST	R31,-Y
     6CF B60F      IN	R0,0x3F
     6D0 920A      ST	R0,-Y
(0404) }
(0405) 
(0406) #pragma interrupt_handler timer1_ovf_isr:iv_TIM1_OVF
(0407) void timer1_ovf_isr(void) {
(0408) 	//TIMER1 has overflowed
(0409) 	TCNT1H = 0x94; //reload counter high value
     6D1 E984      LDI	R24,0x94
     6D2 9380 0085 STS	0x0085,R24
(0410) 	TCNT1L = 0x01; //reload counter low value
     6D4 E081      LDI	R24,1
     6D5 9380 0084 STS	0x0084,R24
(0411) 	delay_count++;
     6D7 9180 0204 LDS	R24,delay_count
     6D9 9190 0205 LDS	R25,delay_count+1
     6DB 9601      ADIW	R24,1
     6DC 9390 0205 STS	delay_count+1,R25
     6DE 9380 0204 STS	delay_count,R24
(0412) 	arm_number++;
     6E0 9180 0200 LDS	R24,arm_number
     6E2 5F8F      SUBI	R24,0xFF
     6E3 9380 0200 STS	arm_number,R24
(0413) 	if (arm_number > 7) {
     6E5 E087      LDI	R24,7
     6E6 9020 0200 LDS	R2,arm_number
     6E8 1582      CP	R24,R2
     6E9 F418      BCC	0x06ED
(0414) 		arm_number = 0;
     6EA 2422      CLR	R2
     6EB 9220 0200 STS	arm_number,R2
(0415) 	}
(0416) 
(0417) 	if (arm_number == 0) {
     6ED 9020 0200 LDS	R2,arm_number
     6EF 2022      TST	R2
     6F0 F519      BNE	0x0714
(0418) 		set_1A();
     6F1 DE2C      RCALL	_set_1A
(0419) 		set_1B();
     6F2 DE33      RCALL	_set_1B
(0420) 		set_1C();
     6F3 DE3C      RCALL	_set_1C
(0421) 		OCR1AH = angle_upper_byte_1A;
     6F4 9020 0252 LDS	R2,angle_upper_byte_1A
     6F6 9220 0089 STS	0x0089,R2
(0422) 		OCR1AL = angle_lower_byte_1A;
     6F8 9020 0251 LDS	R2,angle_lower_byte_1A
     6FA 9220 0088 STS	0x0088,R2
(0423) 		OCR1BH = angle_upper_byte_1B;
     6FC 9020 024F LDS	R2,angle_upper_byte_1B
     6FE 9030 0250 LDS	R3,angle_upper_byte_1B+1
     700 9220 008B STS	0x008B,R2
(0424) 		OCR1BL = angle_lower_byte_1B;
     702 9020 024D LDS	R2,angle_lower_byte_1B
     704 9030 024E LDS	R3,angle_lower_byte_1B+1
     706 9220 008A STS	0x008A,R2
(0425) 		OCR1CH = angle_upper_byte_1C;
     708 9020 024B LDS	R2,angle_upper_byte_1C
     70A 9030 024C LDS	R3,angle_upper_byte_1C+1
     70C 9220 008D STS	0x008D,R2
(0426) 		OCR1CL = angle_lower_byte_1C;
     70E 9020 0249 LDS	R2,angle_lower_byte_1C
     710 9030 024A LDS	R3,angle_lower_byte_1C+1
     712 9220 008C STS	0x008C,R2
(0427) 	}
(0428) 
(0429) 	if (arm_number == 1) {
     714 9180 0200 LDS	R24,arm_number
     716 3081      CPI	R24,1
     717 F519      BNE	0x073B
(0430) 		set_2A();
     718 DE1F      RCALL	_set_2A
(0431) 		set_2B();
     719 DE28      RCALL	_set_2B
(0432) 		set_2C();
     71A DE2F      RCALL	_set_2C
(0433) 		OCR1AH = angle_upper_byte_2A;
     71B 9020 0248 LDS	R2,angle_upper_byte_2A
     71D 9220 0089 STS	0x0089,R2
(0434) 		OCR1AL = angle_lower_byte_2A;
     71F 9020 0247 LDS	R2,angle_lower_byte_2A
     721 9220 0088 STS	0x0088,R2
(0435) 		OCR1BH = angle_upper_byte_2B;
     723 9020 0245 LDS	R2,angle_upper_byte_2B
     725 9030 0246 LDS	R3,angle_upper_byte_2B+1
     727 9220 008B STS	0x008B,R2
(0436) 		OCR1BL = angle_lower_byte_2B;
     729 9020 0243 LDS	R2,angle_lower_byte_2B
     72B 9030 0244 LDS	R3,angle_lower_byte_2B+1
     72D 9220 008A STS	0x008A,R2
(0437) 		OCR1CH = angle_upper_byte_2C;
     72F 9020 0241 LDS	R2,angle_upper_byte_2C
     731 9030 0242 LDS	R3,angle_upper_byte_2C+1
     733 9220 008D STS	0x008D,R2
(0438) 		OCR1CL = angle_lower_byte_2C;
     735 9020 023F LDS	R2,angle_lower_byte_2C
     737 9030 0240 LDS	R3,angle_lower_byte_2C+1
     739 9220 008C STS	0x008C,R2
(0439) 	}
(0440) 
(0441) 	if (arm_number == 2) {
     73B 9180 0200 LDS	R24,arm_number
     73D 3082      CPI	R24,2
     73E F519      BNE	0x0762
(0442) 		set_3A();
     73F DE16      RCALL	_set_3A
(0443) 		set_3B();
     740 DE21      RCALL	_set_3B
(0444) 		set_3C();
     741 DE2C      RCALL	_set_3C
(0445) 		OCR1AH = angle_upper_byte_3A;
     742 9020 023E LDS	R2,angle_upper_byte_3A
     744 9220 0089 STS	0x0089,R2
(0446) 		OCR1AL = angle_lower_byte_3A;
     746 9020 023D LDS	R2,angle_lower_byte_3A
     748 9220 0088 STS	0x0088,R2
(0447) 		OCR1BH = angle_upper_byte_3B;
     74A 9020 023B LDS	R2,angle_upper_byte_3B
     74C 9030 023C LDS	R3,angle_upper_byte_3B+1
     74E 9220 008B STS	0x008B,R2
(0448) 		OCR1BL = angle_lower_byte_3B;
     750 9020 0239 LDS	R2,angle_lower_byte_3B
     752 9030 023A LDS	R3,angle_lower_byte_3B+1
     754 9220 008A STS	0x008A,R2
(0449) 		OCR1CH = angle_upper_byte_3C;
     756 9020 0237 LDS	R2,angle_upper_byte_3C
     758 9030 0238 LDS	R3,angle_upper_byte_3C+1
     75A 9220 008D STS	0x008D,R2
(0450) 		OCR1CL = angle_lower_byte_3C;
     75C 9020 0235 LDS	R2,angle_lower_byte_3C
     75E 9030 0236 LDS	R3,angle_lower_byte_3C+1
     760 9220 008C STS	0x008C,R2
(0451) 	}
(0452) 
(0453) 	if (arm_number == 3) {
     762 9180 0200 LDS	R24,arm_number
     764 3083      CPI	R24,3
     765 F519      BNE	0x0789
(0454) 		set_4A();
     766 DE1D      RCALL	_set_4A
(0455) 		set_4B();
     767 DE22      RCALL	_set_4B
(0456) 		set_4C();
     768 DE27      RCALL	_set_4C
(0457) 		OCR1AH = angle_upper_byte_4A;
     769 9020 0234 LDS	R2,angle_upper_byte_4A
     76B 9220 0089 STS	0x0089,R2
(0458) 		OCR1AL = angle_lower_byte_4A;
     76D 9020 0233 LDS	R2,angle_lower_byte_4A
     76F 9220 0088 STS	0x0088,R2
(0459) 		OCR1BH = angle_upper_byte_4B;
     771 9020 0231 LDS	R2,angle_upper_byte_4B
     773 9030 0232 LDS	R3,angle_upper_byte_4B+1
     775 9220 008B STS	0x008B,R2
(0460) 		OCR1BL = angle_lower_byte_4B;
     777 9020 022F LDS	R2,angle_lower_byte_4B
     779 9030 0230 LDS	R3,angle_lower_byte_4B+1
     77B 9220 008A STS	0x008A,R2
(0461) 		OCR1CH = angle_upper_byte_4C;
     77D 9020 022D LDS	R2,angle_upper_byte_4C
     77F 9030 022E LDS	R3,angle_upper_byte_4C+1
     781 9220 008D STS	0x008D,R2
(0462) 		OCR1CL = angle_lower_byte_4C;
     783 9020 022B LDS	R2,angle_lower_byte_4C
     785 9030 022C LDS	R3,angle_lower_byte_4C+1
     787 9220 008C STS	0x008C,R2
(0463) 	}
(0464) 
(0465) 	if (arm_number == 4) {
     789 9180 0200 LDS	R24,arm_number
     78B 3084      CPI	R24,4
     78C F519      BNE	0x07B0
(0466) 		set_5A();
     78D DE0A      RCALL	_set_5A
(0467) 		set_5B();
     78E DE15      RCALL	_set_5B
(0468) 		set_5C();
     78F DE20      RCALL	_set_5C
(0469) 		OCR1AH = angle_upper_byte_5A;
     790 9020 022A LDS	R2,angle_upper_byte_5A
     792 9220 0089 STS	0x0089,R2
(0470) 		OCR1AL = angle_lower_byte_5A;
     794 9020 0229 LDS	R2,angle_lower_byte_5A
     796 9220 0088 STS	0x0088,R2
(0471) 		OCR1BH = angle_upper_byte_5B;
     798 9020 0227 LDS	R2,angle_upper_byte_5B
     79A 9030 0228 LDS	R3,angle_upper_byte_5B+1
     79C 9220 008B STS	0x008B,R2
(0472) 		OCR1BL = angle_lower_byte_5B;
     79E 9020 0225 LDS	R2,angle_lower_byte_5B
     7A0 9030 0226 LDS	R3,angle_lower_byte_5B+1
     7A2 9220 008A STS	0x008A,R2
(0473) 		OCR1CH = angle_upper_byte_5C;
     7A4 9020 0223 LDS	R2,angle_upper_byte_5C
     7A6 9030 0224 LDS	R3,angle_upper_byte_5C+1
     7A8 9220 008D STS	0x008D,R2
(0474) 		OCR1CL = angle_lower_byte_5C;
     7AA 9020 0221 LDS	R2,angle_lower_byte_5C
     7AC 9030 0222 LDS	R3,angle_lower_byte_5C+1
     7AE 9220 008C STS	0x008C,R2
(0475) 	}
(0476) 
(0477) 	if (arm_number == 5) {
     7B0 9180 0200 LDS	R24,arm_number
     7B2 3085      CPI	R24,5
     7B3 F519      BNE	0x07D7
(0478) 		set_6A();
     7B4 DE07      RCALL	_set_6A
(0479) 		set_6B();
     7B5 DE12      RCALL	_set_6B
(0480) 		set_6C();
     7B6 DE1D      RCALL	_set_6C
(0481) 		OCR1AH = angle_upper_byte_6A;
     7B7 9020 0220 LDS	R2,angle_upper_byte_6A
     7B9 9220 0089 STS	0x0089,R2
(0482) 		OCR1AL = angle_lower_byte_6A;
     7BB 9020 021F LDS	R2,angle_lower_byte_6A
     7BD 9220 0088 STS	0x0088,R2
(0483) 		OCR1BH = angle_upper_byte_6B;
     7BF 9020 021D LDS	R2,angle_upper_byte_6B
     7C1 9030 021E LDS	R3,angle_upper_byte_6B+1
     7C3 9220 008B STS	0x008B,R2
(0484) 		OCR1BL = angle_lower_byte_6B;
     7C5 9020 021B LDS	R2,angle_lower_byte_6B
     7C7 9030 021C LDS	R3,angle_lower_byte_6B+1
     7C9 9220 008A STS	0x008A,R2
(0485) 		OCR1CH = angle_upper_byte_6C;
     7CB 9020 0219 LDS	R2,angle_upper_byte_6C
     7CD 9030 021A LDS	R3,angle_upper_byte_6C+1
     7CF 9220 008D STS	0x008D,R2
(0486) 		OCR1CL = angle_lower_byte_6C;
     7D1 9020 0217 LDS	R2,angle_lower_byte_6C
     7D3 9030 0218 LDS	R3,angle_lower_byte_6C+1
     7D5 9220 008C STS	0x008C,R2
(0487) 	}
     7D7 9009      LD	R0,Y+
     7D8 BE0F      OUT	0x3F,R0
     7D9 91F9      LD	R31,Y+
     7DA 91E9      LD	R30,Y+
     7DB 91B9      LD	R27,Y+
     7DC 91A9      LD	R26,Y+
     7DD 9199      LD	R25,Y+
     7DE 9189      LD	R24,Y+
     7DF 9139      LD	R19,Y+
     7E0 9129      LD	R18,Y+
     7E1 9119      LD	R17,Y+
     7E2 9109      LD	R16,Y+
     7E3 9099      LD	R9,Y+
     7E4 9089      LD	R8,Y+
     7E5 9079      LD	R7,Y+
     7E6 9069      LD	R6,Y+
     7E7 9059      LD	R5,Y+
     7E8 9049      LD	R4,Y+
     7E9 9039      LD	R3,Y+
     7EA 9029      LD	R2,Y+
     7EB 9019      LD	R1,Y+
     7EC 9009      LD	R0,Y+
     7ED 9518      RETI
(0488) 	//serial communication related code
(0489) 	/*serial_communication_interval++;
(0490) 	if (serial_communication_interval > 40) //gives time interval of 40*2.5ms = 100ms
(0491) 	{
(0492) 		serial_communication_interval = 0;
(0493) 		serial_communication_channel_number++;
(0494) 		if (serial_communication_channel_number > 4) //set maximum number of command (can be set up to 7)
(0495) 		{
(0496) 			serial_communication_channel_number = 3; //set first command to begin with (can be set up to 1)
(0497) 		}
(0498) 		UDR0 = serial_communication_channel_number;
(0499) 	}*/
(0500) }
(0501) 
(0502) 
(0503) 
(0504) 
(0505) 
(0506) //UART0 initialize
(0507) // desired baud rate: 9600
(0508) // actual: baud rate:9600 (0.0%)
(0509) // char size: 8 bit
(0510) // parity: Disabled
(0511) void uart0_init(void) {
(0512) 	UCSR0B = 0x00; //disable while setting baud rate
_uart0_init:
     7EE 2422      CLR	R2
     7EF 9220 00C1 STS	0x00C1,R2
(0513) 	UCSR0A = 0x00;
     7F1 9220 00C0 STS	0x00C0,R2
(0514) 	UCSR0C = 0x06;
     7F3 E086      LDI	R24,6
     7F4 9380 00C2 STS	0x00C2,R24
(0515) 	UBRR0L = 0x47; //set baud rate lo
     7F6 E487      LDI	R24,0x47
     7F7 9380 00C4 STS	0x00C4,R24
(0516) 	UBRR0H = 0x00; //set baud rate hi
     7F9 9220 00C5 STS	0x00C5,R2
(0517) 	UCSR0B = 0x98;
     7FB E988      LDI	R24,0x98
     7FC 9380 00C1 STS	0x00C1,R24
     7FE 9508      RET
(0518) }
(0519) 
(0520) 
(0521) 
(0522) //call this routine to initialize all peripherals
(0523) void init_devices(void) {
(0524) 	//stop errant interrupts until set up
(0525) 	CLI(); //disable all interrupts
_init_devices:
     7FF 94F8      BCLR	7
(0526) 	XMCRA = 0x00; //external memory
     800 2422      CLR	R2
     801 9220 0074 STS	0x0074,R2
(0527) 	XMCRB = 0x00; //external memory
     803 9220 0075 STS	0x0075,R2
(0528) 	port_init();
     805 DCB9      RCALL	_port_init
(0529) 	timer1_init();
     806 DCE0      RCALL	_timer1_init
(0530) 	uart0_init();
     807 DFE6      RCALL	_uart0_init
(0531) 
(0532) 	MCUCR = 0x00;
     808 2422      CLR	R2
     809 BE25      OUT	0x35,R2
(0533) 	EICRA = 0x00; //pin change int edge 0:3
     80A 9220 0069 STS	0x0069,R2
(0534) 	EICRB = 0x00; //pin change int edge 4:7
     80C 9220 006A STS	0x006A,R2
(0535) 	PCICR = 0x00; //pin change int enable
     80E 9220 0068 STS	0x0068,R2
(0536) 	PCMSK0 = 0x00; //pin change mask
     810 9220 006B STS	0x006B,R2
(0537) 	PCMSK1 = 0x00; //pin change mask
     812 9220 006C STS	0x006C,R2
(0538) 	PCMSK2 = 0x00; //pin change mask
     814 9220 006D STS	0x006D,R2
(0539) 	EIMSK = 0x00;
     816 BA2D      OUT	0x1D,R2
(0540) 	TIMSK0 = 0x00; //timer0 interrupt sources
     817 9220 006E STS	0x006E,R2
(0541) 	TIMSK1 = 0x0F; //timer1 interrupt sources
     819 E08F      LDI	R24,0xF
     81A 9380 006F STS	0x006F,R24
(0542) 	TIMSK2 = 0x00; //timer2 interrupt sources
     81C 9220 0070 STS	0x0070,R2
(0543) 	TIMSK3 = 0x00; //timer3 interrupt sources
     81E 9220 0071 STS	0x0071,R2
(0544) 	TIMSK4 = 0x00; //timer4 interrupt sources
     820 9220 0072 STS	0x0072,R2
(0545) 	TIMSK5 = 0x00; //timer5 interrupt sources
     822 9220 0073 STS	0x0073,R2
(0546) 
(0547) 	SEI(); //re-enable interrupts
     824 9478      BSET	7
     825 9508      RET
_uart0_rx_isr:
     826 920A      ST	R0,-Y
     827 921A      ST	R1,-Y
     828 922A      ST	R2,-Y
     829 923A      ST	R3,-Y
     82A 924A      ST	R4,-Y
     82B 925A      ST	R5,-Y
     82C 926A      ST	R6,-Y
     82D 927A      ST	R7,-Y
     82E 928A      ST	R8,-Y
     82F 929A      ST	R9,-Y
     830 930A      ST	R16,-Y
     831 931A      ST	R17,-Y
     832 932A      ST	R18,-Y
     833 933A      ST	R19,-Y
     834 938A      ST	R24,-Y
     835 939A      ST	R25,-Y
     836 93AA      ST	R26,-Y
     837 93BA      ST	R27,-Y
     838 93EA      ST	R30,-Y
     839 93FA      ST	R31,-Y
     83A B60F      IN	R0,0x3F
     83B 920A      ST	R0,-Y
(0548) 	//all peripherals are now initialized
(0549) }
(0550) 
(0551) #pragma interrupt_handler uart0_rx_isr:iv_USART0_RXC
(0552) void uart0_rx_isr(void) {
(0553) 	//uart has received a character in UDR
(0554) 	
(0555) 	//buzzer_on();
(0556) 	
(0557) 	data = UDR0;
     83C 9020 00C6 LDS	R2,0x00C6
     83E 9220 020E STS	data,R2
(0558) 	UDR0 = data;
     840 9220 00C6 STS	0x00C6,R2
(0559) 	if(KEYBOARD_ON)
(0560) 	    keyboard_control();
     842 940E 12F2 CALL	_keyboard_control
     844 9009      LD	R0,Y+
     845 BE0F      OUT	0x3F,R0
     846 91F9      LD	R31,Y+
     847 91E9      LD	R30,Y+
     848 91B9      LD	R27,Y+
     849 91A9      LD	R26,Y+
     84A 9199      LD	R25,Y+
     84B 9189      LD	R24,Y+
     84C 9139      LD	R19,Y+
     84D 9129      LD	R18,Y+
     84E 9119      LD	R17,Y+
     84F 9109      LD	R16,Y+
     850 9099      LD	R9,Y+
     851 9089      LD	R8,Y+
     852 9079      LD	R7,Y+
     853 9069      LD	R6,Y+
     854 9059      LD	R5,Y+
     855 9049      LD	R4,Y+
     856 9039      LD	R3,Y+
     857 9029      LD	R2,Y+
     858 9019      LD	R1,Y+
     859 9009      LD	R0,Y+
     85A 9518      RETI
(0561) }
(0562) 
(0563) void servo_on(void) {
(0564) 	PORTB = PORTB | 0x01;
_servo_on:
     85B 9A28      SBI	0x05,0
     85C 9508      RET
(0565) }
(0566) 
(0567) void servo_off(void) {
(0568) 	PORTB = PORTB & 0xFE;
_servo_off:
     85D B185      IN	R24,0x05
     85E 7F8E      ANDI	R24,0xFE
     85F B985      OUT	0x05,R24
     860 9508      RET
(0569) }
(0570) 
(0571) void reset_SP_LEFT(void) {
(0572) 	PORTL = PORTL & 0xFD;
_reset_SP_LEFT:
     861 9180 010B LDS	R24,0x010B
     863 7F8D      ANDI	R24,0xFD
     864 9380 010B STS	0x010B,R24
     866 9508      RET
(0573) }
(0574) 
(0575) void set_SP_LEFT(void) {
(0576) 	PORTL = PORTL | 0x02;
_set_SP_LEFT:
     867 9180 010B LDS	R24,0x010B
     869 6082      ORI	R24,2
     86A 9380 010B STS	0x010B,R24
     86C 9508      RET
(0577) }
(0578) 
(0579) 
(0580) void angle_value_calculation(void) {
(0581) 	unsigned int angle_value = 0;
_angle_value_calculation:
  temp                 --> R16
  angle_value          --> R18
     86D 2722      CLR	R18
     86E 2733      CLR	R19
(0582) 	unsigned int temp = 0;
     86F 2700      CLR	R16
     870 2711      CLR	R17
(0583) 	if (degree > 180)
     871 EB84      LDI	R24,0xB4
     872 9020 0203 LDS	R2,degree
     874 1582      CP	R24,R2
     875 F410      BCC	0x0878
(0584) 		degree = 180; // limiting the scope of the servo rotation
     876 9380 0203 STS	degree,R24
(0585) 
(0586) 	angle_value = 0xBF39 + (64 * (unsigned char) degree); //actual constant is 64.4
     878 9020 0203 LDS	R2,degree
     87A E480      LDI	R24,0x40
     87B 9D82      MUL	R24,R2
     87C 0190      MOVW	R18,R0
     87D 5C27      SUBI	R18,0xC7
     87E 4430      SBCI	R19,0x40
(0587) 
(0588) 	angle_lower_byte = (unsigned char) angle_value; //separating the lower byte
     87F 9320 0202 STS	angle_lower_byte,R18
(0589) 
(0590) 	temp = angle_value >> 8;
     881 0189      MOVW	R16,R18
     882 2F01      MOV	R16,R17
     883 2711      CLR	R17
(0591) 	angle_upper_byte = (unsigned char) temp; //separating the upper byte
     884 9300 0201 STS	angle_upper_byte,R16
     886 9508      RET
_angle_1A:
  angle                --> R10
     887 92AA      ST	R10,-Y
     888 2EA0      MOV	R10,R16
(0592) }
(0593) 
(0594) void angle_1A(unsigned char angle) {
(0595) 	degree = angle;
     889 92A0 0203 STS	degree,R10
(0596) 	angle_value_calculation();
     88B DFE1      RCALL	_angle_value_calculation
(0597) 	angle_upper_byte_1A = angle_upper_byte;
     88C 9020 0201 LDS	R2,angle_upper_byte
     88E 9220 0252 STS	angle_upper_byte_1A,R2
(0598) 	angle_lower_byte_1A = angle_lower_byte;
     890 9020 0202 LDS	R2,angle_lower_byte
     892 9220 0251 STS	angle_lower_byte_1A,R2
     894 90A9      LD	R10,Y+
     895 9508      RET
_angle_1B:
  angle                --> R10
     896 92AA      ST	R10,-Y
     897 2EA0      MOV	R10,R16
(0599) }
(0600) 
(0601) void angle_1B(unsigned char angle) {
(0602) 	degree = angle;
     898 92A0 0203 STS	degree,R10
(0603) 	angle_value_calculation();
     89A DFD2      RCALL	_angle_value_calculation
(0604) 	angle_upper_byte_1B = angle_upper_byte;
     89B 9020 0201 LDS	R2,angle_upper_byte
     89D 2433      CLR	R3
     89E 9230 0250 STS	angle_upper_byte_1B+1,R3
     8A0 9220 024F STS	angle_upper_byte_1B,R2
(0605) 	angle_lower_byte_1B = angle_lower_byte;
     8A2 9020 0202 LDS	R2,angle_lower_byte
     8A4 2433      CLR	R3
     8A5 9230 024E STS	angle_lower_byte_1B+1,R3
     8A7 9220 024D STS	angle_lower_byte_1B,R2
     8A9 90A9      LD	R10,Y+
     8AA 9508      RET
_angle_1C:
  angle                --> R10
     8AB 92AA      ST	R10,-Y
     8AC 2EA0      MOV	R10,R16
(0606) }
(0607) 
(0608) void angle_1C(unsigned char angle) {
(0609) 	degree = angle;
     8AD 92A0 0203 STS	degree,R10
(0610) 	angle_value_calculation();
     8AF DFBD      RCALL	_angle_value_calculation
(0611) 	angle_upper_byte_1C = angle_upper_byte;
     8B0 9020 0201 LDS	R2,angle_upper_byte
     8B2 2433      CLR	R3
     8B3 9230 024C STS	angle_upper_byte_1C+1,R3
     8B5 9220 024B STS	angle_upper_byte_1C,R2
(0612) 	angle_lower_byte_1C = angle_lower_byte;
     8B7 9020 0202 LDS	R2,angle_lower_byte
     8B9 2433      CLR	R3
     8BA 9230 024A STS	angle_lower_byte_1C+1,R3
     8BC 9220 0249 STS	angle_lower_byte_1C,R2
     8BE 90A9      LD	R10,Y+
     8BF 9508      RET
_angle_2A:
  angle                --> R10
     8C0 92AA      ST	R10,-Y
     8C1 2EA0      MOV	R10,R16
(0613) }
(0614) 
(0615) void angle_2A(unsigned char angle) {
(0616) 	degree = angle;
     8C2 92A0 0203 STS	degree,R10
(0617) 	angle_value_calculation();
     8C4 DFA8      RCALL	_angle_value_calculation
(0618) 	angle_upper_byte_2A = angle_upper_byte;
     8C5 9020 0201 LDS	R2,angle_upper_byte
     8C7 9220 0248 STS	angle_upper_byte_2A,R2
(0619) 	angle_lower_byte_2A = angle_lower_byte;
     8C9 9020 0202 LDS	R2,angle_lower_byte
     8CB 9220 0247 STS	angle_lower_byte_2A,R2
     8CD 90A9      LD	R10,Y+
     8CE 9508      RET
_angle_2B:
  angle                --> R10
     8CF 92AA      ST	R10,-Y
     8D0 2EA0      MOV	R10,R16
(0620) }
(0621) 
(0622) void angle_2B(unsigned char angle) {
(0623) 	degree = angle;
     8D1 92A0 0203 STS	degree,R10
(0624) 	angle_value_calculation();
     8D3 DF99      RCALL	_angle_value_calculation
(0625) 	angle_upper_byte_2B = angle_upper_byte;
     8D4 9020 0201 LDS	R2,angle_upper_byte
     8D6 2433      CLR	R3
     8D7 9230 0246 STS	angle_upper_byte_2B+1,R3
     8D9 9220 0245 STS	angle_upper_byte_2B,R2
(0626) 	angle_lower_byte_2B = angle_lower_byte;
     8DB 9020 0202 LDS	R2,angle_lower_byte
     8DD 2433      CLR	R3
     8DE 9230 0244 STS	angle_lower_byte_2B+1,R3
     8E0 9220 0243 STS	angle_lower_byte_2B,R2
     8E2 90A9      LD	R10,Y+
     8E3 9508      RET
_angle_2C:
  angle                --> R10
     8E4 92AA      ST	R10,-Y
     8E5 2EA0      MOV	R10,R16
(0627) }
(0628) 
(0629) void angle_2C(unsigned char angle) {
(0630) 	degree = angle;
     8E6 92A0 0203 STS	degree,R10
(0631) 	angle_value_calculation();
     8E8 DF84      RCALL	_angle_value_calculation
(0632) 	angle_upper_byte_2C = angle_upper_byte;
     8E9 9020 0201 LDS	R2,angle_upper_byte
     8EB 2433      CLR	R3
     8EC 9230 0242 STS	angle_upper_byte_2C+1,R3
     8EE 9220 0241 STS	angle_upper_byte_2C,R2
(0633) 	angle_lower_byte_2C = angle_lower_byte;
     8F0 9020 0202 LDS	R2,angle_lower_byte
     8F2 2433      CLR	R3
     8F3 9230 0240 STS	angle_lower_byte_2C+1,R3
     8F5 9220 023F STS	angle_lower_byte_2C,R2
     8F7 90A9      LD	R10,Y+
     8F8 9508      RET
_angle_3A:
  angle                --> R10
     8F9 92AA      ST	R10,-Y
     8FA 2EA0      MOV	R10,R16
(0634) }
(0635) 
(0636) void angle_3A(unsigned char angle) {
(0637) 	degree = angle;
     8FB 92A0 0203 STS	degree,R10
(0638) 	angle_value_calculation();
     8FD DF6F      RCALL	_angle_value_calculation
(0639) 	angle_upper_byte_3A = angle_upper_byte;
     8FE 9020 0201 LDS	R2,angle_upper_byte
     900 9220 023E STS	angle_upper_byte_3A,R2
(0640) 	angle_lower_byte_3A = angle_lower_byte;
     902 9020 0202 LDS	R2,angle_lower_byte
     904 9220 023D STS	angle_lower_byte_3A,R2
     906 90A9      LD	R10,Y+
     907 9508      RET
_angle_3B:
  angle                --> R10
     908 92AA      ST	R10,-Y
     909 2EA0      MOV	R10,R16
(0641) }
(0642) 
(0643) void angle_3B(unsigned char angle) {
(0644) 	degree = angle;
     90A 92A0 0203 STS	degree,R10
(0645) 	angle_value_calculation();
     90C DF60      RCALL	_angle_value_calculation
(0646) 	angle_upper_byte_3B = angle_upper_byte;
     90D 9020 0201 LDS	R2,angle_upper_byte
     90F 2433      CLR	R3
     910 9230 023C STS	angle_upper_byte_3B+1,R3
     912 9220 023B STS	angle_upper_byte_3B,R2
(0647) 	angle_lower_byte_3B = angle_lower_byte;
     914 9020 0202 LDS	R2,angle_lower_byte
     916 2433      CLR	R3
     917 9230 023A STS	angle_lower_byte_3B+1,R3
     919 9220 0239 STS	angle_lower_byte_3B,R2
     91B 90A9      LD	R10,Y+
     91C 9508      RET
_angle_3C:
  angle                --> R10
     91D 92AA      ST	R10,-Y
     91E 2EA0      MOV	R10,R16
(0648) }
(0649) 
(0650) void angle_3C(unsigned char angle) {
(0651) 	degree = angle;
     91F 92A0 0203 STS	degree,R10
(0652) 	angle_value_calculation();
     921 DF4B      RCALL	_angle_value_calculation
(0653) 	angle_upper_byte_3C = angle_upper_byte;
     922 9020 0201 LDS	R2,angle_upper_byte
     924 2433      CLR	R3
     925 9230 0238 STS	angle_upper_byte_3C+1,R3
     927 9220 0237 STS	angle_upper_byte_3C,R2
(0654) 	angle_lower_byte_3C = angle_lower_byte;
     929 9020 0202 LDS	R2,angle_lower_byte
     92B 2433      CLR	R3
     92C 9230 0236 STS	angle_lower_byte_3C+1,R3
     92E 9220 0235 STS	angle_lower_byte_3C,R2
     930 90A9      LD	R10,Y+
     931 9508      RET
_angle_4A:
  angle                --> R10
     932 92AA      ST	R10,-Y
     933 2EA0      MOV	R10,R16
(0655) }
(0656) 
(0657) void angle_4A(unsigned char angle) {
(0658) 	degree = angle;
     934 92A0 0203 STS	degree,R10
(0659) 	angle_value_calculation();
     936 DF36      RCALL	_angle_value_calculation
(0660) 	angle_upper_byte_4A = angle_upper_byte;
     937 9020 0201 LDS	R2,angle_upper_byte
     939 9220 0234 STS	angle_upper_byte_4A,R2
(0661) 	angle_lower_byte_4A = angle_lower_byte;
     93B 9020 0202 LDS	R2,angle_lower_byte
     93D 9220 0233 STS	angle_lower_byte_4A,R2
     93F 90A9      LD	R10,Y+
     940 9508      RET
_angle_4B:
  angle                --> R10
     941 92AA      ST	R10,-Y
     942 2EA0      MOV	R10,R16
(0662) }
(0663) 
(0664) void angle_4B(unsigned char angle) {
(0665) 	degree = angle;
     943 92A0 0203 STS	degree,R10
(0666) 	angle_value_calculation();
     945 DF27      RCALL	_angle_value_calculation
(0667) 	angle_upper_byte_4B = angle_upper_byte;
     946 9020 0201 LDS	R2,angle_upper_byte
     948 2433      CLR	R3
     949 9230 0232 STS	angle_upper_byte_4B+1,R3
     94B 9220 0231 STS	angle_upper_byte_4B,R2
(0668) 	angle_lower_byte_4B = angle_lower_byte;
     94D 9020 0202 LDS	R2,angle_lower_byte
     94F 2433      CLR	R3
     950 9230 0230 STS	angle_lower_byte_4B+1,R3
     952 9220 022F STS	angle_lower_byte_4B,R2
     954 90A9      LD	R10,Y+
     955 9508      RET
_angle_4C:
  angle                --> R10
     956 92AA      ST	R10,-Y
     957 2EA0      MOV	R10,R16
(0669) }
(0670) 
(0671) void angle_4C(unsigned char angle) {
(0672) 	degree = angle;
     958 92A0 0203 STS	degree,R10
(0673) 	angle_value_calculation();
     95A DF12      RCALL	_angle_value_calculation
(0674) 	angle_upper_byte_4C = angle_upper_byte;
     95B 9020 0201 LDS	R2,angle_upper_byte
     95D 2433      CLR	R3
     95E 9230 022E STS	angle_upper_byte_4C+1,R3
     960 9220 022D STS	angle_upper_byte_4C,R2
(0675) 	angle_lower_byte_4C = angle_lower_byte;
     962 9020 0202 LDS	R2,angle_lower_byte
     964 2433      CLR	R3
     965 9230 022C STS	angle_lower_byte_4C+1,R3
     967 9220 022B STS	angle_lower_byte_4C,R2
     969 90A9      LD	R10,Y+
     96A 9508      RET
_angle_5A:
  angle                --> R10
     96B 92AA      ST	R10,-Y
     96C 2EA0      MOV	R10,R16
(0676) }
(0677) 
(0678) void angle_5A(unsigned char angle) {
(0679) 	degree = angle;
     96D 92A0 0203 STS	degree,R10
(0680) 	angle_value_calculation();
     96F DEFD      RCALL	_angle_value_calculation
(0681) 	angle_upper_byte_5A = angle_upper_byte;
     970 9020 0201 LDS	R2,angle_upper_byte
     972 9220 022A STS	angle_upper_byte_5A,R2
(0682) 	angle_lower_byte_5A = angle_lower_byte;
     974 9020 0202 LDS	R2,angle_lower_byte
     976 9220 0229 STS	angle_lower_byte_5A,R2
     978 90A9      LD	R10,Y+
     979 9508      RET
_angle_5B:
  angle                --> R10
     97A 92AA      ST	R10,-Y
     97B 2EA0      MOV	R10,R16
(0683) }
(0684) 
(0685) void angle_5B(unsigned char angle) {
(0686) 	degree = angle;
     97C 92A0 0203 STS	degree,R10
(0687) 	angle_value_calculation();
     97E DEEE      RCALL	_angle_value_calculation
(0688) 	angle_upper_byte_5B = angle_upper_byte;
     97F 9020 0201 LDS	R2,angle_upper_byte
     981 2433      CLR	R3
     982 9230 0228 STS	angle_upper_byte_5B+1,R3
     984 9220 0227 STS	angle_upper_byte_5B,R2
(0689) 	angle_lower_byte_5B = angle_lower_byte;
     986 9020 0202 LDS	R2,angle_lower_byte
     988 2433      CLR	R3
     989 9230 0226 STS	angle_lower_byte_5B+1,R3
     98B 9220 0225 STS	angle_lower_byte_5B,R2
     98D 90A9      LD	R10,Y+
     98E 9508      RET
_angle_5C:
  angle                --> R10
     98F 92AA      ST	R10,-Y
     990 2EA0      MOV	R10,R16
(0690) }
(0691) 
(0692) void angle_5C(unsigned char angle) {
(0693) 	degree = angle;
     991 92A0 0203 STS	degree,R10
(0694) 	angle_value_calculation();
     993 DED9      RCALL	_angle_value_calculation
(0695) 	angle_upper_byte_5C = angle_upper_byte;
     994 9020 0201 LDS	R2,angle_upper_byte
     996 2433      CLR	R3
     997 9230 0224 STS	angle_upper_byte_5C+1,R3
     999 9220 0223 STS	angle_upper_byte_5C,R2
(0696) 	angle_lower_byte_5C = angle_lower_byte;
     99B 9020 0202 LDS	R2,angle_lower_byte
     99D 2433      CLR	R3
     99E 9230 0222 STS	angle_lower_byte_5C+1,R3
     9A0 9220 0221 STS	angle_lower_byte_5C,R2
     9A2 90A9      LD	R10,Y+
     9A3 9508      RET
_angle_6A:
  angle                --> R10
     9A4 92AA      ST	R10,-Y
     9A5 2EA0      MOV	R10,R16
(0697) }
(0698) 
(0699) void angle_6A(unsigned char angle) {
(0700) 	degree = angle;
     9A6 92A0 0203 STS	degree,R10
(0701) 	angle_value_calculation();
     9A8 DEC4      RCALL	_angle_value_calculation
(0702) 	angle_upper_byte_6A = angle_upper_byte;
     9A9 9020 0201 LDS	R2,angle_upper_byte
     9AB 9220 0220 STS	angle_upper_byte_6A,R2
(0703) 	angle_lower_byte_6A = angle_lower_byte;
     9AD 9020 0202 LDS	R2,angle_lower_byte
     9AF 9220 021F STS	angle_lower_byte_6A,R2
     9B1 90A9      LD	R10,Y+
     9B2 9508      RET
_angle_6B:
  angle                --> R10
     9B3 92AA      ST	R10,-Y
     9B4 2EA0      MOV	R10,R16
(0704) }
(0705) 
(0706) void angle_6B(unsigned char angle) {
(0707) 	degree = angle;
     9B5 92A0 0203 STS	degree,R10
(0708) 	angle_value_calculation();
     9B7 DEB5      RCALL	_angle_value_calculation
(0709) 	angle_upper_byte_6B = angle_upper_byte;
     9B8 9020 0201 LDS	R2,angle_upper_byte
     9BA 2433      CLR	R3
     9BB 9230 021E STS	angle_upper_byte_6B+1,R3
     9BD 9220 021D STS	angle_upper_byte_6B,R2
(0710) 	angle_lower_byte_6B = angle_lower_byte;
     9BF 9020 0202 LDS	R2,angle_lower_byte
     9C1 2433      CLR	R3
     9C2 9230 021C STS	angle_lower_byte_6B+1,R3
     9C4 9220 021B STS	angle_lower_byte_6B,R2
     9C6 90A9      LD	R10,Y+
     9C7 9508      RET
_angle_6C:
  angle                --> R10
     9C8 92AA      ST	R10,-Y
     9C9 2EA0      MOV	R10,R16
(0711) }
(0712) 
(0713) void angle_6C(unsigned char angle) {
(0714) 	degree = angle;
     9CA 92A0 0203 STS	degree,R10
(0715) 	angle_value_calculation();
     9CC DEA0      RCALL	_angle_value_calculation
(0716) 	angle_upper_byte_6C = angle_upper_byte;
     9CD 9020 0201 LDS	R2,angle_upper_byte
     9CF 2433      CLR	R3
     9D0 9230 021A STS	angle_upper_byte_6C+1,R3
     9D2 9220 0219 STS	angle_upper_byte_6C,R2
(0717) 	angle_lower_byte_6C = angle_lower_byte;
     9D4 9020 0202 LDS	R2,angle_lower_byte
     9D6 2433      CLR	R3
     9D7 9230 0218 STS	angle_lower_byte_6C+1,R3
     9D9 9220 0217 STS	angle_lower_byte_6C,R2
     9DB 90A9      LD	R10,Y+
     9DC 9508      RET
(0718) }
(0719) 
(0720) 
(0721) 
(0722) void servo_calibration(void) {
(0723) 	angle_1A(90);
_servo_calibration:
     9DD E50A      LDI	R16,0x5A
     9DE DEA8      RCALL	_angle_1A
(0724) 	angle_1B(90);
     9DF E50A      LDI	R16,0x5A
     9E0 DEB5      RCALL	_angle_1B
(0725) 	angle_1C(90);
     9E1 E50A      LDI	R16,0x5A
     9E2 DEC8      RCALL	_angle_1C
(0726) 	angle_2A(90);
     9E3 E50A      LDI	R16,0x5A
     9E4 DEDB      RCALL	_angle_2A
(0727) 	angle_2B(90);
     9E5 E50A      LDI	R16,0x5A
     9E6 DEE8      RCALL	_angle_2B
(0728) 	angle_2C(90);
     9E7 E50A      LDI	R16,0x5A
     9E8 DEFB      RCALL	_angle_2C
(0729) 	angle_3A(90);
     9E9 E50A      LDI	R16,0x5A
     9EA DF0E      RCALL	_angle_3A
(0730) 	angle_3B(90);
     9EB E50A      LDI	R16,0x5A
     9EC DF1B      RCALL	_angle_3B
(0731) 	angle_3C(90);
     9ED E50A      LDI	R16,0x5A
     9EE DF2E      RCALL	_angle_3C
(0732) 	angle_4A(90);
     9EF E50A      LDI	R16,0x5A
     9F0 DF41      RCALL	_angle_4A
(0733) 	angle_4B(90);
     9F1 E50A      LDI	R16,0x5A
     9F2 DF4E      RCALL	_angle_4B
(0734) 	angle_4C(90);
     9F3 E50A      LDI	R16,0x5A
     9F4 DF61      RCALL	_angle_4C
(0735) 	angle_5A(90);
     9F5 E50A      LDI	R16,0x5A
     9F6 DF74      RCALL	_angle_5A
(0736) 	angle_5B(90);
     9F7 E50A      LDI	R16,0x5A
     9F8 DF81      RCALL	_angle_5B
(0737) 	angle_5C(90);
     9F9 E50A      LDI	R16,0x5A
     9FA DF94      RCALL	_angle_5C
(0738) 	angle_6A(90);
     9FB E50A      LDI	R16,0x5A
     9FC DFA7      RCALL	_angle_6A
(0739) 	angle_6B(90);
     9FD E50A      LDI	R16,0x5A
     9FE DFB4      RCALL	_angle_6B
(0740) 	angle_6C(90);
     9FF E50A      LDI	R16,0x5A
     A00 DFC7      RCALL	_angle_6C
     A01 9508      RET
(0741) }
(0742) 
(0743) void even_A_servo_90(void) {
(0744) 	angle_2A(90);
_even_A_servo_90:
     A02 E50A      LDI	R16,0x5A
     A03 DEBC      RCALL	_angle_2A
(0745) 	angle_4A(90);
     A04 E50A      LDI	R16,0x5A
     A05 DF2C      RCALL	_angle_4A
(0746) 	angle_6A(90);
     A06 E50A      LDI	R16,0x5A
     A07 DF9C      RCALL	_angle_6A
     A08 9508      RET
(0747) }
(0748) 
(0749) void even_A_servo_65(void) //clockwise
(0750) {
(0751) 	angle_2A(65);
_even_A_servo_65:
     A09 E401      LDI	R16,0x41
     A0A DEB5      RCALL	_angle_2A
(0752) 	angle_4A(65);
     A0B E401      LDI	R16,0x41
     A0C DF25      RCALL	_angle_4A
(0753) 	angle_6A(65);
     A0D E401      LDI	R16,0x41
     A0E DF95      RCALL	_angle_6A
     A0F 9508      RET
(0754) }
(0755) 
(0756) void even_A_servo_115(void)//anticlockwise_
(0757) {
(0758) 	angle_2A(115);
_even_A_servo_115:
     A10 E703      LDI	R16,0x73
     A11 DEAE      RCALL	_angle_2A
(0759) 	angle_4A(115);
     A12 E703      LDI	R16,0x73
     A13 DF1E      RCALL	_angle_4A
(0760) 	angle_6A(115);
     A14 E703      LDI	R16,0x73
     A15 DF8E      RCALL	_angle_6A
     A16 9508      RET
(0761) }
(0762) 
(0763) void even_BC_servo_90(void) {
(0764) 	angle_2B(90);
_even_BC_servo_90:
     A17 E50A      LDI	R16,0x5A
     A18 DEB6      RCALL	_angle_2B
(0765) 	angle_2C(90);
     A19 E50A      LDI	R16,0x5A
     A1A DEC9      RCALL	_angle_2C
(0766) 	angle_4B(90);
     A1B E50A      LDI	R16,0x5A
     A1C DF24      RCALL	_angle_4B
(0767) 	angle_4C(90);
     A1D E50A      LDI	R16,0x5A
     A1E DF37      RCALL	_angle_4C
(0768) 	angle_6B(90);
     A1F E50A      LDI	R16,0x5A
     A20 DF92      RCALL	_angle_6B
(0769) 	angle_6C(90);
     A21 E50A      LDI	R16,0x5A
     A22 DFA5      RCALL	_angle_6C
     A23 9508      RET
(0770) }
(0771) 
(0772) void even_BC_servo_up_45(void) {
(0773) 	angle_2B(45);
_even_BC_servo_up_45:
     A24 E20D      LDI	R16,0x2D
     A25 DEA9      RCALL	_angle_2B
(0774) 	angle_2C(90);
     A26 E50A      LDI	R16,0x5A
     A27 DEBC      RCALL	_angle_2C
(0775) 	angle_4B(135);
     A28 E807      LDI	R16,0x87
     A29 DF17      RCALL	_angle_4B
(0776) 	angle_4C(90);
     A2A E50A      LDI	R16,0x5A
     A2B DF2A      RCALL	_angle_4C
(0777) 	angle_6B(135);
     A2C E807      LDI	R16,0x87
     A2D DF85      RCALL	_angle_6B
(0778) 	angle_6C(90);
     A2E E50A      LDI	R16,0x5A
     A2F DF98      RCALL	_angle_6C
     A30 9508      RET
(0779) }
(0780) 
(0781) void even_BC_servo_down_45(void) {
(0782) 	angle_2B(135);
_even_BC_servo_down_45:
     A31 E807      LDI	R16,0x87
     A32 DE9C      RCALL	_angle_2B
(0783) 	angle_2C(135);
     A33 E807      LDI	R16,0x87
     A34 DEAF      RCALL	_angle_2C
(0784) 	angle_4B(45);
     A35 E20D      LDI	R16,0x2D
     A36 DF0A      RCALL	_angle_4B
(0785) 	angle_4C(45);
     A37 E20D      LDI	R16,0x2D
     A38 DF1D      RCALL	_angle_4C
(0786) 	angle_6B(45);
     A39 E20D      LDI	R16,0x2D
     A3A DF78      RCALL	_angle_6B
(0787) 	angle_6C(45);
     A3B E20D      LDI	R16,0x2D
     A3C DF8B      RCALL	_angle_6C
     A3D 9508      RET
(0788) }
(0789) 
(0790) void odd_A_servo_90(void) {
(0791) 	angle_1A(90);
_odd_A_servo_90:
     A3E E50A      LDI	R16,0x5A
     A3F DE47      RCALL	_angle_1A
(0792) 	angle_3A(90);
     A40 E50A      LDI	R16,0x5A
     A41 DEB7      RCALL	_angle_3A
(0793) 	angle_5A(90);
     A42 E50A      LDI	R16,0x5A
     A43 DF27      RCALL	_angle_5A
     A44 9508      RET
(0794) }
(0795) 
(0796) void odd_A_servo_65(void)//clockwise
(0797) {
(0798) 	angle_1A(65);
_odd_A_servo_65:
     A45 E401      LDI	R16,0x41
     A46 DE40      RCALL	_angle_1A
(0799) 	angle_3A(65);
     A47 E401      LDI	R16,0x41
     A48 DEB0      RCALL	_angle_3A
(0800) 	angle_5A(65);
     A49 E401      LDI	R16,0x41
     A4A DF20      RCALL	_angle_5A
     A4B 9508      RET
(0801) }
(0802) 
(0803) void odd_A_servo_115(void) //anticlockwise
(0804) {
(0805) 	angle_1A(115);
_odd_A_servo_115:
     A4C E703      LDI	R16,0x73
     A4D DE39      RCALL	_angle_1A
(0806) 	angle_3A(115);
     A4E E703      LDI	R16,0x73
     A4F DEA9      RCALL	_angle_3A
(0807) 	angle_5A(115);
     A50 E703      LDI	R16,0x73
     A51 DF19      RCALL	_angle_5A
     A52 9508      RET
(0808) }
(0809) 
(0810) void odd_BC_servo_90(void) {
(0811) 	angle_1B(90);
_odd_BC_servo_90:
     A53 E50A      LDI	R16,0x5A
     A54 DE41      RCALL	_angle_1B
(0812) 	angle_1C(90);
     A55 E50A      LDI	R16,0x5A
     A56 DE54      RCALL	_angle_1C
(0813) 	angle_3B(90);
     A57 E50A      LDI	R16,0x5A
     A58 DEAF      RCALL	_angle_3B
(0814) 	angle_3C(90);
     A59 E50A      LDI	R16,0x5A
     A5A DEC2      RCALL	_angle_3C
(0815) 	angle_5B(90);
     A5B E50A      LDI	R16,0x5A
     A5C DF1D      RCALL	_angle_5B
(0816) 	angle_5C(90);
     A5D E50A      LDI	R16,0x5A
     A5E DF30      RCALL	_angle_5C
     A5F 9508      RET
(0817) }
(0818) 
(0819) void odd_BC_servo_up_45(void) {
(0820) 	angle_1B(45);
_odd_BC_servo_up_45:
     A60 E20D      LDI	R16,0x2D
     A61 DE34      RCALL	_angle_1B
(0821) 	angle_1C(90);
     A62 E50A      LDI	R16,0x5A
     A63 DE47      RCALL	_angle_1C
(0822) 	angle_3B(45);
     A64 E20D      LDI	R16,0x2D
     A65 DEA2      RCALL	_angle_3B
(0823) 	angle_3C(90);
     A66 E50A      LDI	R16,0x5A
     A67 DEB5      RCALL	_angle_3C
(0824) 	angle_5B(135);
     A68 E807      LDI	R16,0x87
     A69 DF10      RCALL	_angle_5B
(0825) 	angle_5C(90);
     A6A E50A      LDI	R16,0x5A
     A6B DF23      RCALL	_angle_5C
     A6C 9508      RET
(0826) }
(0827) 
(0828) void odd_BC_servo_down_45(void) {
(0829) 	angle_1B(135);
_odd_BC_servo_down_45:
     A6D E807      LDI	R16,0x87
     A6E DE27      RCALL	_angle_1B
(0830) 	angle_1C(135);
     A6F E807      LDI	R16,0x87
     A70 DE3A      RCALL	_angle_1C
(0831) 	angle_3B(135);
     A71 E807      LDI	R16,0x87
     A72 DE95      RCALL	_angle_3B
(0832) 	angle_3C(135);
     A73 E807      LDI	R16,0x87
     A74 DEA8      RCALL	_angle_3C
(0833) 	angle_5B(45);
     A75 E20D      LDI	R16,0x2D
     A76 DF03      RCALL	_angle_5B
(0834) 	angle_5C(45);
     A77 E20D      LDI	R16,0x2D
     A78 DF16      RCALL	_angle_5C
     A79 9508      RET
(0835) }
(0836) 
(0837) void robot_rotate_clockwise_7_5(void) {
(0838) 	motion_busy = 1;
_robot_rotate_clockwise_7_5:
     A7A E081      LDI	R24,1
     A7B 9380 0209 STS	motion_busy,R24
(0839) 	servo_calibration();
     A7D DF5F      RCALL	_servo_calibration
(0840) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     A7E E604      LDI	R16,0x64
     A7F E010      LDI	R17,0
     A80 D129      RCALL	_delay
(0841) 	even_A_servo_65();
     A81 DF87      RCALL	_even_A_servo_65
(0842) 	even_BC_servo_up_45();
     A82 DFA1      RCALL	_even_BC_servo_up_45
(0843) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     A83 E604      LDI	R16,0x64
     A84 E010      LDI	R17,0
     A85 D124      RCALL	_delay
(0844) 	even_BC_servo_90();
     A86 DF90      RCALL	_even_BC_servo_90
(0845) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     A87 E604      LDI	R16,0x64
     A88 E010      LDI	R17,0
     A89 D120      RCALL	_delay
(0846) 	odd_A_servo_65();
     A8A DFBA      RCALL	_odd_A_servo_65
(0847) 	odd_BC_servo_up_45();
     A8B DFD4      RCALL	_odd_BC_servo_up_45
(0848) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     A8C E604      LDI	R16,0x64
     A8D E010      LDI	R17,0
     A8E D11B      RCALL	_delay
(0849) 	odd_BC_servo_90();
     A8F DFC3      RCALL	_odd_BC_servo_90
(0850) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     A90 E604      LDI	R16,0x64
     A91 E010      LDI	R17,0
     A92 D117      RCALL	_delay
(0851) 	even_A_servo_90();
     A93 DF6E      RCALL	_even_A_servo_90
(0852) 	odd_A_servo_90();
     A94 DFA9      RCALL	_odd_A_servo_90
(0853) 	motion_busy = 0;
     A95 2422      CLR	R2
     A96 9220 0209 STS	motion_busy,R2
     A98 9508      RET
(0854) }
(0855) 
(0856) void robot_rotate_anticlockwise_7_5(void) {
(0857) 	motion_busy = 1;
_robot_rotate_anticlockwise_7_5:
     A99 E081      LDI	R24,1
     A9A 9380 0209 STS	motion_busy,R24
(0858) 	servo_calibration();
     A9C DF40      RCALL	_servo_calibration
(0859) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     A9D E604      LDI	R16,0x64
     A9E E010      LDI	R17,0
     A9F D10A      RCALL	_delay
(0860) 	even_A_servo_115();
     AA0 DF6F      RCALL	_even_A_servo_115
(0861) 	even_BC_servo_up_45();
     AA1 DF82      RCALL	_even_BC_servo_up_45
(0862) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AA2 E604      LDI	R16,0x64
     AA3 E010      LDI	R17,0
     AA4 D105      RCALL	_delay
(0863) 	even_BC_servo_90();
     AA5 DF71      RCALL	_even_BC_servo_90
(0864) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AA6 E604      LDI	R16,0x64
     AA7 E010      LDI	R17,0
     AA8 D101      RCALL	_delay
(0865) 	odd_A_servo_115();
     AA9 DFA2      RCALL	_odd_A_servo_115
(0866) 	odd_BC_servo_up_45();
     AAA DFB5      RCALL	_odd_BC_servo_up_45
(0867) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AAB E604      LDI	R16,0x64
     AAC E010      LDI	R17,0
     AAD D0FC      RCALL	_delay
(0868) 	odd_BC_servo_90();
     AAE DFA4      RCALL	_odd_BC_servo_90
(0869) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AAF E604      LDI	R16,0x64
     AB0 E010      LDI	R17,0
     AB1 D0F8      RCALL	_delay
(0870) 	even_A_servo_90();
     AB2 DF4F      RCALL	_even_A_servo_90
(0871) 	odd_A_servo_90();
     AB3 DF8A      RCALL	_odd_A_servo_90
(0872) 	motion_busy = 0;
     AB4 2422      CLR	R2
     AB5 9220 0209 STS	motion_busy,R2
     AB7 9508      RET
(0873) }
(0874) 
(0875) //forward by using two legs at a time
(0876) void forward(void) {
(0877) 	motion_busy = 1;
_forward:
     AB8 E081      LDI	R24,1
     AB9 9380 0209 STS	motion_busy,R24
(0878) 	servo_calibration();
     ABB DF21      RCALL	_servo_calibration
(0879) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     ABC E604      LDI	R16,0x64
     ABD E010      LDI	R17,0
     ABE D0EB      RCALL	_delay
(0880) 
(0881) 	//legs 2 and 4 move forward
(0882) 	angle_2B(45);
     ABF E20D      LDI	R16,0x2D
     AC0 DE0E      RCALL	_angle_2B
(0883) 	angle_2C(45);
     AC1 E20D      LDI	R16,0x2D
     AC2 DE21      RCALL	_angle_2C
(0884) 	angle_4B(135);
     AC3 E807      LDI	R16,0x87
     AC4 DE7C      RCALL	_angle_4B
(0885) 	angle_4C(135); //front pair BC servo up 45
     AC5 E807      LDI	R16,0x87
     AC6 DE8F      RCALL	_angle_4C
(0886) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AC7 E604      LDI	R16,0x64
     AC8 E010      LDI	R17,0
     AC9 D0E0      RCALL	_delay
(0887) 	angle_2A(45);
     ACA E20D      LDI	R16,0x2D
     ACB DDF4      RCALL	_angle_2A
(0888) 	angle_4A(135); //front pair move forward while legs are up
     ACC E807      LDI	R16,0x87
     ACD DE64      RCALL	_angle_4A
(0889) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     ACE E604      LDI	R16,0x64
     ACF E010      LDI	R17,0
     AD0 D0D9      RCALL	_delay
(0890) 	angle_2B(90);
     AD1 E50A      LDI	R16,0x5A
     AD2 DDFC      RCALL	_angle_2B
(0891) 	angle_2C(90);
     AD3 E50A      LDI	R16,0x5A
     AD4 DE0F      RCALL	_angle_2C
(0892) 	angle_4B(90);
     AD5 E50A      LDI	R16,0x5A
     AD6 DE6A      RCALL	_angle_4B
(0893) 	angle_4C(90); // put down legs
     AD7 E50A      LDI	R16,0x5A
     AD8 DE7D      RCALL	_angle_4C
(0894) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AD9 E604      LDI	R16,0x64
     ADA E010      LDI	R17,0
     ADB D0CE      RCALL	_delay
(0895) 
(0896) 	//legs 1 and 6 move forward
(0897) 
(0898) 	angle_1B(45);
     ADC E20D      LDI	R16,0x2D
     ADD DDB8      RCALL	_angle_1B
(0899) 	angle_1C(45);
     ADE E20D      LDI	R16,0x2D
     ADF DDCB      RCALL	_angle_1C
(0900) 	angle_6B(135);
     AE0 E807      LDI	R16,0x87
     AE1 DED1      RCALL	_angle_6B
(0901) 	angle_6C(135); //middel pair BC servo up 45
     AE2 E807      LDI	R16,0x87
     AE3 DEE4      RCALL	_angle_6C
(0902) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AE4 E604      LDI	R16,0x64
     AE5 E010      LDI	R17,0
     AE6 D0C3      RCALL	_delay
(0903) 	angle_1A(45);
     AE7 E20D      LDI	R16,0x2D
     AE8 DD9E      RCALL	_angle_1A
(0904) 	angle_6A(135); //middel pair move back while legs are up
     AE9 E807      LDI	R16,0x87
     AEA DEB9      RCALL	_angle_6A
(0905) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AEB E604      LDI	R16,0x64
     AEC E010      LDI	R17,0
     AED D0BC      RCALL	_delay
(0906) 	angle_1B(90);
     AEE E50A      LDI	R16,0x5A
     AEF DDA6      RCALL	_angle_1B
(0907) 	angle_1C(90);
     AF0 E50A      LDI	R16,0x5A
     AF1 DDB9      RCALL	_angle_1C
(0908) 	angle_6B(90);
     AF2 E50A      LDI	R16,0x5A
     AF3 DEBF      RCALL	_angle_6B
(0909) 	angle_6C(90); // put down legs
     AF4 E50A      LDI	R16,0x5A
     AF5 DED2      RCALL	_angle_6C
(0910) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     AF6 E604      LDI	R16,0x64
     AF7 E010      LDI	R17,0
     AF8 D0B1      RCALL	_delay
(0911) 
(0912) 	//legs 3 and 5 move forward
(0913) 	angle_3B(45);
     AF9 E20D      LDI	R16,0x2D
     AFA DE0D      RCALL	_angle_3B
(0914) 	angle_3C(45);
     AFB E20D      LDI	R16,0x2D
     AFC DE20      RCALL	_angle_3C
(0915) 	angle_5B(135);
     AFD E807      LDI	R16,0x87
     AFE DE7B      RCALL	_angle_5B
(0916) 	angle_5C(135); //middel pair BC servo up 45
     AFF E807      LDI	R16,0x87
     B00 DE8E      RCALL	_angle_5C
(0917) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B01 E604      LDI	R16,0x64
     B02 E010      LDI	R17,0
     B03 D0A6      RCALL	_delay
(0918) 	angle_3A(45);
     B04 E20D      LDI	R16,0x2D
     B05 DDF3      RCALL	_angle_3A
(0919) 	angle_5A(135); //middel pair move forward while legs are up
     B06 E807      LDI	R16,0x87
     B07 DE63      RCALL	_angle_5A
(0920) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B08 E604      LDI	R16,0x64
     B09 E010      LDI	R17,0
     B0A D09F      RCALL	_delay
(0921) 	angle_3B(90);
     B0B E50A      LDI	R16,0x5A
     B0C DDFB      RCALL	_angle_3B
(0922) 	angle_3C(90);
     B0D E50A      LDI	R16,0x5A
     B0E DE0E      RCALL	_angle_3C
(0923) 	angle_5B(90);
     B0F E50A      LDI	R16,0x5A
     B10 DE69      RCALL	_angle_5B
(0924) 	angle_5C(90); // put down legs
     B11 E50A      LDI	R16,0x5A
     B12 DE7C      RCALL	_angle_5C
(0925) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B13 E604      LDI	R16,0x64
     B14 E010      LDI	R17,0
     B15 D094      RCALL	_delay
(0926) 
(0927) 	servo_calibration(); //push towards forward
     B16 DEC6      RCALL	_servo_calibration
(0928) 	motion_busy = 0;
     B17 2422      CLR	R2
     B18 9220 0209 STS	motion_busy,R2
     B1A 9508      RET
(0929) }
(0930) 
(0931) //backward by using two legs at a time
(0932) void back(void) {
(0933) 	motion_busy = 1;
_back:
     B1B E081      LDI	R24,1
     B1C 9380 0209 STS	motion_busy,R24
(0934) 	servo_calibration();
     B1E DEBE      RCALL	_servo_calibration
(0935) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B1F E604      LDI	R16,0x64
     B20 E010      LDI	R17,0
     B21 D088      RCALL	_delay
(0936) 
(0937) 	//legs 2 and 4 move back
(0938) 	angle_2B(45);
     B22 E20D      LDI	R16,0x2D
     B23 DDAB      RCALL	_angle_2B
(0939) 	angle_2C(45);
     B24 E20D      LDI	R16,0x2D
     B25 DDBE      RCALL	_angle_2C
(0940) 	angle_4B(135);
     B26 E807      LDI	R16,0x87
     B27 DE19      RCALL	_angle_4B
(0941) 	angle_4C(135); //front pair BC servo up 45
     B28 E807      LDI	R16,0x87
     B29 DE2C      RCALL	_angle_4C
(0942) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B2A E604      LDI	R16,0x64
     B2B E010      LDI	R17,0
     B2C D07D      RCALL	_delay
(0943) 	angle_2A(135);
     B2D E807      LDI	R16,0x87
     B2E DD91      RCALL	_angle_2A
(0944) 	angle_4A(45); //front pair move forward while legs are up
     B2F E20D      LDI	R16,0x2D
     B30 DE01      RCALL	_angle_4A
(0945) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B31 E604      LDI	R16,0x64
     B32 E010      LDI	R17,0
     B33 D076      RCALL	_delay
(0946) 	angle_2B(90);
     B34 E50A      LDI	R16,0x5A
     B35 DD99      RCALL	_angle_2B
(0947) 	angle_2C(90);
     B36 E50A      LDI	R16,0x5A
     B37 DDAC      RCALL	_angle_2C
(0948) 	angle_4B(90);
     B38 E50A      LDI	R16,0x5A
     B39 DE07      RCALL	_angle_4B
(0949) 	angle_4C(90); // put down legs
     B3A E50A      LDI	R16,0x5A
     B3B DE1A      RCALL	_angle_4C
(0950) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B3C E604      LDI	R16,0x64
     B3D E010      LDI	R17,0
     B3E D06B      RCALL	_delay
(0951) 
(0952) 	//legs 1 and 6 move back
(0953) 
(0954) 	angle_1B(45);
     B3F E20D      LDI	R16,0x2D
     B40 DD55      RCALL	_angle_1B
(0955) 	angle_1C(45);
     B41 E20D      LDI	R16,0x2D
     B42 DD68      RCALL	_angle_1C
(0956) 	angle_6B(135);
     B43 E807      LDI	R16,0x87
     B44 DE6E      RCALL	_angle_6B
(0957) 	angle_6C(135); //middel pair BC servo up 45
     B45 E807      LDI	R16,0x87
     B46 DE81      RCALL	_angle_6C
(0958) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B47 E604      LDI	R16,0x64
     B48 E010      LDI	R17,0
     B49 D060      RCALL	_delay
(0959) 	angle_1A(135);
     B4A E807      LDI	R16,0x87
     B4B DD3B      RCALL	_angle_1A
(0960) 	angle_6A(45); //middel pair move back while legs are up
     B4C E20D      LDI	R16,0x2D
     B4D DE56      RCALL	_angle_6A
(0961) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B4E E604      LDI	R16,0x64
     B4F E010      LDI	R17,0
     B50 D059      RCALL	_delay
(0962) 	angle_1B(90);
     B51 E50A      LDI	R16,0x5A
     B52 DD43      RCALL	_angle_1B
(0963) 	angle_1C(90);
     B53 E50A      LDI	R16,0x5A
     B54 DD56      RCALL	_angle_1C
(0964) 	angle_6B(90);
     B55 E50A      LDI	R16,0x5A
     B56 DE5C      RCALL	_angle_6B
(0965) 	angle_6C(90); // put down legs
     B57 E50A      LDI	R16,0x5A
     B58 DE6F      RCALL	_angle_6C
(0966) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B59 E604      LDI	R16,0x64
     B5A E010      LDI	R17,0
     B5B D04E      RCALL	_delay
(0967) 
(0968) 	//legs 3 and 5 move back
(0969) 	angle_3B(45);
     B5C E20D      LDI	R16,0x2D
     B5D DDAA      RCALL	_angle_3B
(0970) 	angle_3C(45);
     B5E E20D      LDI	R16,0x2D
     B5F DDBD      RCALL	_angle_3C
(0971) 	angle_5B(135);
     B60 E807      LDI	R16,0x87
     B61 DE18      RCALL	_angle_5B
(0972) 	angle_5C(135); //middel pair BC servo up 45
     B62 E807      LDI	R16,0x87
     B63 DE2B      RCALL	_angle_5C
(0973) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B64 E604      LDI	R16,0x64
     B65 E010      LDI	R17,0
     B66 D043      RCALL	_delay
(0974) 	angle_3A(135);
     B67 E807      LDI	R16,0x87
     B68 DD90      RCALL	_angle_3A
(0975) 	angle_5A(45); //middel pair move forward while legs are up
     B69 E20D      LDI	R16,0x2D
     B6A DE00      RCALL	_angle_5A
(0976) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B6B E604      LDI	R16,0x64
     B6C E010      LDI	R17,0
     B6D D03C      RCALL	_delay
(0977) 	angle_3B(90);
     B6E E50A      LDI	R16,0x5A
     B6F DD98      RCALL	_angle_3B
(0978) 	angle_3C(90);
     B70 E50A      LDI	R16,0x5A
     B71 DDAB      RCALL	_angle_3C
(0979) 	angle_5B(90);
     B72 E50A      LDI	R16,0x5A
     B73 DE06      RCALL	_angle_5B
(0980) 	angle_5C(90); // put down legs
     B74 E50A      LDI	R16,0x5A
     B75 DE19      RCALL	_angle_5C
(0981) 	delay(TWO_HUNDRED_FIFTY_MSEC);
     B76 E604      LDI	R16,0x64
     B77 E010      LDI	R17,0
     B78 D031      RCALL	_delay
(0982) 
(0983) 	servo_calibration(); //push towards back
     B79 DE63      RCALL	_servo_calibration
(0984) 	motion_busy = 0;
     B7A 2422      CLR	R2
     B7B 9220 0209 STS	motion_busy,R2
     B7D 9508      RET
(0985) }
(0986) 
(0987) 
(0988) void robot_standup(void) //warning: do not call this function while robot is standing or servos will get damaged
(0989) {
(0990) 	motion_busy = 1;
_robot_standup:
     B7E E081      LDI	R24,1
     B7F 9380 0209 STS	motion_busy,R24
(0991) 	angle_1B(1);
     B81 E001      LDI	R16,1
     B82 DD13      RCALL	_angle_1B
(0992) 	angle_1C(110);
     B83 E60E      LDI	R16,0x6E
     B84 DD26      RCALL	_angle_1C
(0993) 	angle_2B(1);
     B85 E001      LDI	R16,1
     B86 DD48      RCALL	_angle_2B
(0994) 	angle_2C(110);
     B87 E60E      LDI	R16,0x6E
     B88 DD5B      RCALL	_angle_2C
(0995) 	angle_3B(1);
     B89 E001      LDI	R16,1
     B8A DD7D      RCALL	_angle_3B
(0996) 	angle_3C(110);
     B8B E60E      LDI	R16,0x6E
     B8C DD90      RCALL	_angle_3C
(0997) 	angle_4B(179);
     B8D EB03      LDI	R16,0xB3
     B8E DDB2      RCALL	_angle_4B
(0998) 	angle_4C(70);
     B8F E406      LDI	R16,0x46
     B90 DDC5      RCALL	_angle_4C
(0999) 	angle_5B(179);
     B91 EB03      LDI	R16,0xB3
     B92 DDE7      RCALL	_angle_5B
(1000) 	angle_5C(70);
     B93 E406      LDI	R16,0x46
     B94 DDFA      RCALL	_angle_5C
(1001) 	angle_6B(179);
     B95 EB03      LDI	R16,0xB3
     B96 DE1C      RCALL	_angle_6B
(1002) 	angle_6C(70);
     B97 E406      LDI	R16,0x46
     B98 DE2F      RCALL	_angle_6C
(1003) 	delay(ONE_SEC);
     B99 E900      LDI	R16,0x90
     B9A E011      LDI	R17,1
     B9B D00E      RCALL	_delay
(1004) 	delay(ONE_SEC);
     B9C E900      LDI	R16,0x90
     B9D E011      LDI	R17,1
     B9E D00B      RCALL	_delay
(1005) 	servo_calibration();
     B9F DE3D      RCALL	_servo_calibration
(1006) 	motion_busy = 0;
     BA0 2422      CLR	R2
     BA1 9220 0209 STS	motion_busy,R2
     BA3 9508      RET
(1007) }
(1008) 
(1009) //set buzzer on
(1010) void buzzer_on(void) {
(1011) 	PORTC = PORTC | 0x08;
_buzzer_on:
     BA4 9A43      SBI	0x08,3
     BA5 9508      RET
(1012) }
(1013) 
(1014) //set buzzer off
(1015) void buzzer_off(void) {
(1016) 	PORTC = PORTC & 0xF7;
_buzzer_off:
     BA6 B188      IN	R24,0x08
     BA7 7F87      ANDI	R24,0xF7
     BA8 B988      OUT	0x08,R24
     BA9 9508      RET
(1017) }
(1018) 
(1019) /*
(1020) void remote_control(void) {
(1021) 	unsigned char flag1 = 0;
(1022) 	PORTA = remote_data[4]; //move left joystick up and down and see if there is any change in the bargraph display.
(1023) 	flag1 = 0; //resetting the flag
(1024) 
(1025) 	if ((flag1 == 0) && (motion_busy == 0)) //forward, 1 beep
(1026) 	{
(1027) 		if (remote_data[4] > 0x29) {
(1028) 			flag1 = 1;
(1029) 			forward();
(1030) 			//buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off(); //use it to debug remote onnection
(1031) 		}
(1032) 	}
(1033) 
(1034) 	if ((flag1 == 0) && (motion_busy == 0)) //back, 2 beep
(1035) 	{
(1036) 		if (remote_data[4] < 0x15) {
(1037) 			flag1 = 1;
(1038) 			back();
(1039) 			//buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off();delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off(); //use it to debug remote onnection
(1040) 		}
(1041) 	}
(1042) 
(1043) 	if ((flag1 == 0) && (motion_busy == 0)) //anticlockwise (left), 3 beep
(1044) 	{
(1045) 		if (remote_data[3] > 0x2D) {
(1046) 			flag1 = 1;
(1047) 			robot_rotate_anticlockwise_7_5();
(1048) 			//buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off();delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off(); //use it to debug remote onnection
(1049) 		}
(1050) 	}
(1051) 
(1052) 	if ((flag1 == 0) && (motion_busy == 0)) //clockwise (right), 4 beep
(1053) 	{
(1054) 		if (remote_data[3] < 0x19) {
(1055) 			flag1 = 1;
(1056) 			robot_rotate_clockwise_7_5();
(1057) 			//buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off();delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off();delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off(); //use it to debug remote onnection
(1058) 		}
(1059) 	}
(1060) 
(1061) 	if ((flag1 == 0) && (motion_busy == 0)) //stop 1 long beep
(1062) 	{
(1063) 		if ((0x19 < remote_data[3] < 0x2D) && (0x15 < remote_data[4] < 0x29)) {
(1064) 			flag1 = 1;
(1065) 			servo_calibration();
(1066) 			//buzzer_on(); delay(TWO_HUNDRED_FIFTY_MSEC); delay(TWO_HUNDRED_FIFTY_MSEC); delay(TWO_HUNDRED_FIFTY_MSEC); buzzer_off(); //use it to debug remote onnection
(1067) 		}
(1068) 	}
(1069) }*/
(1070) 
(1071) 
(1072) void delay(int time) {
(1073) 	delay_count = 0;
_delay:
  time                 --> R16
     BAA 2422      CLR	R2
     BAB 2433      CLR	R3
     BAC 9230 0205 STS	delay_count+1,R3
     BAE 9220 0204 STS	delay_count,R2
(1074) 	while (delay_count < time)
     BB0 9020 0204 LDS	R2,delay_count
     BB2 9030 0205 LDS	R3,delay_count+1
     BB4 1620      CP	R2,R16
     BB5 0631      CPC	R3,R17
     BB6 F3C8      BCS	0x0BB0
     BB7 9508      RET
_ADC_Conversion:
  a                    --> R10
  Ch                   --> R16
     BB8 92AA      ST	R10,-Y
(1075) 		;
(1076) }
(1077) 
(1078) unsigned char ADC_Conversion(unsigned char Ch)
(1079) {
(1080) 	unsigned char a;
(1081) 	if(Ch>7)
     BB9 E087      LDI	R24,7
     BBA 1780      CP	R24,R16
     BBB F418      BCC	0x0BBF
(1082) 		{
(1083) 		ADCSRB = 0x08;			// select the ch. > 7
     BBC E088      LDI	R24,0x8
     BBD 9380 007B STS	0x007B,R24
(1084) 		}
(1085) 	Ch = Ch & 0x07;  			
     BBF 7007      ANDI	R16,7
(1086) 	ADMUX= 0x20| Ch;	   		//do not disturb the left adjustment
     BC0 2F80      MOV	R24,R16
     BC1 6280      ORI	R24,0x20
     BC2 9380 007C STS	0x007C,R24
(1087) 	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     BC4 9180 007A LDS	R24,0x007A
     BC6 6480      ORI	R24,0x40
     BC7 9380 007A STS	0x007A,R24
(1088) 	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
     BC9 9020 007A LDS	R2,0x007A
     BCB FE24      SBRS	R2,4
     BCC CFFC      RJMP	0x0BC9
(1089) 	a=ADCH;
     BCD 90A0 0079 LDS	R10,0x0079
(1090) 	ADCSRA = ADCSRA|0x10; 		//clear ADIF (ADC Interrupt Flag) by writing 1 to it
     BCF 9180 007A LDS	R24,0x007A
     BD1 6180      ORI	R24,0x10
     BD2 9380 007A STS	0x007A,R24
(1091) 	ADCSRB = 0x00;
     BD4 2422      CLR	R2
     BD5 9220 007B STS	0x007B,R2
(1092) 	return a;
     BD7 2D0A      MOV	R16,R10
     BD8 90A9      LD	R10,Y+
     BD9 9508      RET
_initializeAngles:
  i                    --> R20
  j                    --> R22
     BDA 940E 13C5 CALL	push_xgsetF000
FILE: D:\BUILDI~1\hexapod_basic.c
(0001) /***
(0002) Author : Srijit Dutt
(0003) Date Sun 07 Nov 2010 02:42:38 PM IST 
(0004) 
(0005) hexapod_basic.c : File contains various basic motion functions for the hexapod
(0006) Please include hexapod_basic.h file to call function from this file
(0007) 
(0008) */
(0009) 
(0010) /********************************************************************************
(0011) 
(0012)    Copyright (c) 2010, ERTS Lab IIT Bombay erts@cse.iitb.ac.in               -*- c -*-
(0013)    All rights reserved.
(0014) 
(0015)    Redistribution and use in source and binary forms, with or without
(0016)    modification, are permitted provided that the following conditions are met:
(0017) 
(0018)    * Redistributions of source code must retain the above copyright
(0019)      notice, this list of conditions and the following disclaimer.
(0020) 
(0021)    * Redistributions in binary form must reproduce the above copyright
(0022)      notice, this list of conditions and the following disclaimer in
(0023)      the documentation and/or other materials provided with the
(0024)      distribution.
(0025) 
(0026)    * Neither the name of the copyright holders nor the names of
(0027)      contributors may be used to endorse or promote products derived
(0028)      from this software without specific prior written permission.
(0029) 
(0030)    * Source code can be used for academic purpose. 
(0031) 	 For commercial use permission form the author needs to be taken.
(0032) 
(0033)   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
(0034)   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
(0035)   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
(0036)   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
(0037)   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
(0038)   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
(0039)   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
(0040)   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
(0041)   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
(0042)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
(0043)   POSSIBILITY OF SUCH DAMAGE. 
(0044) 
(0045)   Software released under Creative Commence cc by-nc-sa licence.
(0046)   For legal information refer to: 
(0047)   http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode
(0048) 
(0049) ********************************************************************************/
(0050) 
(0051) 
(0052) #include "hexapod_macro.h"
(0053) #include "hexapod.h"
(0054) 
(0055) 
(0056) 
(0057) unsigned char angleArr[6][3];//!< The angle of the servos
(0058) static unsigned char dirMirror = DIR_MIRROR_LEG_1_2;
(0059) 
(0060) /**
(0061) Initialize the servo angles
(0062) */
(0063) void initializeAngles() {
(0064) 	 int i,j;
(0065) 	 
(0066) 	 for (i=0; i < NO_OF_LEGS; i++) {
     BDC 2744      CLR	R20
     BDD 2755      CLR	R21
(0067) 	 	 for(j=0; j < NO_OF_SERVOS_IN_EACH_LEG; j++) {
     BDE 2766      CLR	R22
     BDF 2777      CLR	R23
(0068) 		 		  angleArr[i][j] = INITIAL_ANGLE;
     BE0 E003      LDI	R16,3
     BE1 E010      LDI	R17,0
     BE2 019A      MOVW	R18,R20
     BE3 940E 1396 CALL	empy16s
     BE5 0118      MOVW	R2,R16
     BE6 E583      LDI	R24,0x53
     BE7 E092      LDI	R25,2
     BE8 0E28      ADD	R2,R24
     BE9 1E39      ADC	R3,R25
     BEA 01FB      MOVW	R30,R22
     BEB 0DE2      ADD	R30,R2
     BEC 1DF3      ADC	R31,R3
     BED E58A      LDI	R24,0x5A
     BEE 8380      STD	Z+0,R24
     BEF 5F6F      SUBI	R22,0xFF
     BF0 4F7F      SBCI	R23,0xFF
     BF1 3063      CPI	R22,3
     BF2 E0E0      LDI	R30,0
     BF3 077E      CPC	R23,R30
     BF4 F35C      BLT	0x0BE0
     BF5 5F4F      SUBI	R20,0xFF
     BF6 4F5F      SBCI	R21,0xFF
     BF7 3046      CPI	R20,6
     BF8 E0E0      LDI	R30,0
     BF9 075E      CPC	R21,R30
     BFA F31C      BLT	0x0BDE
     BFB 940C 13CA JMP	pop_xgsetF000
_angle:
  angle                --> R10
  motor                --> R20
  arm                  --> R12
     BFD 940E 13DD CALL	push_xgsetF03C
     BFF 2F42      MOV	R20,R18
     C00 2EC0      MOV	R12,R16
     C01 9721      SBIW	R28,1
     C02 84A9      LDD	R10,Y+9
(0069) 		 }
(0070) 	 }
(0071) }
(0072) 
(0073) /**
(0074) * Set the servo angle
(0075) */
(0076) void setAngle(unsigned char arm, unsigned char motor, unsigned char angle);
(0077) 
(0078) /**
(0079) Get the servo angle
(0080) */
(0081) unsigned char getAngle(unsigned char arm, unsigned char motor);
(0082) 
(0083) /**
(0084) Sets a specific servo to a angle
(0085) 
(0086) @param arm : The arm of the hexapod
(0087) @param motor :  The motor of the hexapod
(0088) @param angle : The angle to set the servo to
(0089) */
(0090) void angle(unsigned char arm, unsigned char motor, unsigned char angle) {
(0091) 	setAngle(arm, motor, angle); 
     C03 82A8      STD	Y+0,R10
     C04 2F24      MOV	R18,R20
     C05 2D0C      MOV	R16,R12
     C06 D10E      RCALL	_setAngle
(0092) 	switch (arm) {
     C07 2D6C      MOV	R22,R12
     C08 2777      CLR	R23
     C09 3061      CPI	R22,1
     C0A E0E0      LDI	R30,0
     C0B 077E      CPC	R23,R30
     C0C F0C9      BEQ	0x0C26
     C0D 3062      CPI	R22,2
     C0E E0E0      LDI	R30,0
     C0F 077E      CPC	R23,R30
     C10 F141      BEQ	0x0C39
     C11 3063      CPI	R22,3
     C12 E0E0      LDI	R30,0
     C13 077E      CPC	R23,R30
     C14 F409      BNE	0x0C16
     C15 C036      RJMP	0x0C4C
     C16 3064      CPI	R22,4
     C17 E0E0      LDI	R30,0
     C18 077E      CPC	R23,R30
     C19 F409      BNE	0x0C1B
     C1A C044      RJMP	0x0C5F
     C1B 3065      CPI	R22,5
     C1C E0E0      LDI	R30,0
     C1D 077E      CPC	R23,R30
     C1E F409      BNE	0x0C20
     C1F C05A      RJMP	0x0C7A
     C20 3066      CPI	R22,6
     C21 E0E0      LDI	R30,0
     C22 077E      CPC	R23,R30
     C23 F409      BNE	0x0C25
     C24 C06F      RJMP	0x0C94
     C25 C087      RJMP	0x0CAD
(0093) 	case 1:
(0094) 		if (motor == MOTOR_A)
     C26 3441      CPI	R20,0x41
     C27 F421      BNE	0x0C2C
(0095) 			angle_1A(angle);
     C28 2D0A      MOV	R16,R10
     C29 940E 0887 CALL	_angle_1A
     C2B C081      RJMP	0x0CAD
(0096) 		else if (motor == MOTOR_B)
     C2C 3442      CPI	R20,0x42
     C2D F421      BNE	0x0C32
(0097) 			angle_1B(angle);
     C2E 2D0A      MOV	R16,R10
     C2F 940E 0896 CALL	_angle_1B
     C31 C07B      RJMP	0x0CAD
(0098) 		else if (motor == MOTOR_C)
     C32 3443      CPI	R20,0x43
     C33 F009      BEQ	0x0C35
     C34 C078      RJMP	0x0CAD
(0099) 			angle_1C(angle);
     C35 2D0A      MOV	R16,R10
     C36 940E 08AB CALL	_angle_1C
(0100) 		break;
     C38 C074      RJMP	0x0CAD
(0101) 	case 2:
(0102) 		if (motor == MOTOR_A)
     C39 3441      CPI	R20,0x41
     C3A F421      BNE	0x0C3F
(0103) 			angle_2A(angle);
     C3B 2D0A      MOV	R16,R10
     C3C 940E 08C0 CALL	_angle_2A
     C3E C06E      RJMP	0x0CAD
(0104) 		else if (motor == MOTOR_B)
     C3F 3442      CPI	R20,0x42
     C40 F421      BNE	0x0C45
(0105) 			angle_2B(angle);
     C41 2D0A      MOV	R16,R10
     C42 940E 08CF CALL	_angle_2B
     C44 C068      RJMP	0x0CAD
(0106) 		else if (motor == MOTOR_C)
     C45 3443      CPI	R20,0x43
     C46 F009      BEQ	0x0C48
     C47 C065      RJMP	0x0CAD
(0107) 			angle_2C(angle);
     C48 2D0A      MOV	R16,R10
     C49 940E 08E4 CALL	_angle_2C
(0108) 		break;
     C4B C061      RJMP	0x0CAD
(0109) 	case 3:
(0110) 		if (motor == MOTOR_A)
     C4C 3441      CPI	R20,0x41
     C4D F421      BNE	0x0C52
(0111) 			angle_3A(angle);
     C4E 2D0A      MOV	R16,R10
     C4F 940E 08F9 CALL	_angle_3A
     C51 C05B      RJMP	0x0CAD
(0112) 		else if (motor == MOTOR_B)
     C52 3442      CPI	R20,0x42
     C53 F421      BNE	0x0C58
(0113) 			angle_3B(angle);
     C54 2D0A      MOV	R16,R10
     C55 940E 0908 CALL	_angle_3B
     C57 C055      RJMP	0x0CAD
(0114) 		else if (motor == MOTOR_C)
     C58 3443      CPI	R20,0x43
     C59 F009      BEQ	0x0C5B
     C5A C052      RJMP	0x0CAD
(0115) 			angle_3C(angle);
     C5B 2D0A      MOV	R16,R10
     C5C 940E 091D CALL	_angle_3C
(0116) 		break;
     C5E C04E      RJMP	0x0CAD
(0117) 	case 4:
(0118) 		if (motor == MOTOR_A)
     C5F 3441      CPI	R20,0x41
     C60 F421      BNE	0x0C65
(0119) 			angle_4A(angle);
     C61 2D0A      MOV	R16,R10
     C62 940E 0932 CALL	_angle_4A
     C64 C048      RJMP	0x0CAD
(0120) 		else if (motor == MOTOR_B)
     C65 3442      CPI	R20,0x42
     C66 F441      BNE	0x0C6F
(0121) 			angle_4B(180 - angle);
     C67 2C2A      MOV	R2,R10
     C68 2433      CLR	R3
     C69 EB04      LDI	R16,0xB4
     C6A 1902      SUB	R16,R2
     C6B 0913      SBC	R17,R3
     C6C 940E 0941 CALL	_angle_4B
     C6E C03E      RJMP	0x0CAD
(0122) 		else if (motor == MOTOR_C)
     C6F 3443      CPI	R20,0x43
     C70 F009      BEQ	0x0C72
     C71 C03B      RJMP	0x0CAD
(0123) 			angle_4C(180 - angle);
     C72 2C2A      MOV	R2,R10
     C73 2433      CLR	R3
     C74 EB04      LDI	R16,0xB4
     C75 1902      SUB	R16,R2
     C76 0913      SBC	R17,R3
     C77 940E 0956 CALL	_angle_4C
(0124) 		break;
     C79 C033      RJMP	0x0CAD
(0125) 	case 5:
(0126) 		if (motor == MOTOR_A)
     C7A 3441      CPI	R20,0x41
     C7B F421      BNE	0x0C80
(0127) 			angle_5A(angle);
     C7C 2D0A      MOV	R16,R10
     C7D 940E 096B CALL	_angle_5A
     C7F C02D      RJMP	0x0CAD
(0128) 		else if (motor == MOTOR_B)
     C80 3442      CPI	R20,0x42
     C81 F441      BNE	0x0C8A
(0129) 			angle_5B(180 - angle);
     C82 2C2A      MOV	R2,R10
     C83 2433      CLR	R3
     C84 EB04      LDI	R16,0xB4
     C85 1902      SUB	R16,R2
     C86 0913      SBC	R17,R3
     C87 940E 097A CALL	_angle_5B
     C89 C023      RJMP	0x0CAD
(0130) 		else if (motor == MOTOR_C)
     C8A 3443      CPI	R20,0x43
     C8B F509      BNE	0x0CAD
(0131) 			angle_5C(180 - angle);
     C8C 2C2A      MOV	R2,R10
     C8D 2433      CLR	R3
     C8E EB04      LDI	R16,0xB4
     C8F 1902      SUB	R16,R2
     C90 0913      SBC	R17,R3
     C91 940E 098F CALL	_angle_5C
(0132) 		break;
     C93 C019      RJMP	0x0CAD
(0133) 	case 6:
(0134) 		if (motor == MOTOR_A)
     C94 3441      CPI	R20,0x41
     C95 F421      BNE	0x0C9A
(0135) 			angle_6A(angle);
     C96 2D0A      MOV	R16,R10
     C97 940E 09A4 CALL	_angle_6A
     C99 C013      RJMP	0x0CAD
(0136) 		else if (motor == MOTOR_B)
     C9A 3442      CPI	R20,0x42
     C9B F441      BNE	0x0CA4
(0137) 			angle_6B(180 - angle);
     C9C 2C2A      MOV	R2,R10
     C9D 2433      CLR	R3
     C9E EB04      LDI	R16,0xB4
     C9F 1902      SUB	R16,R2
     CA0 0913      SBC	R17,R3
     CA1 940E 09B3 CALL	_angle_6B
     CA3 C009      RJMP	0x0CAD
(0138) 		else if (motor == MOTOR_C)
     CA4 3443      CPI	R20,0x43
     CA5 F439      BNE	0x0CAD
(0139) 			angle_6C(180 - angle);
     CA6 2C2A      MOV	R2,R10
     CA7 2433      CLR	R3
     CA8 EB04      LDI	R16,0xB4
     CA9 1902      SUB	R16,R2
     CAA 0913      SBC	R17,R3
     CAB 940E 09C8 CALL	_angle_6C
(0140) 		break;
     CAD 9621      ADIW	R28,1
     CAE 940C 13E6 JMP	pop_xgsetF03C
_angle_XA:
  angle                --> R10
     CB0 92AA      ST	R10,-Y
     CB1 2EA0      MOV	R10,R16
(0141) 	}
(0142) }
(0143) 
(0144) 
(0145) /**
(0146) Sets the angle of all the MOTOR_XA servo
(0147) @param angle : The angle to be set
(0148) */
(0149) void angle_XA(unsigned char angle) {
(0150) 	angle_1A(angle);
     CB2 2D0A      MOV	R16,R10
     CB3 940E 0887 CALL	_angle_1A
(0151) 	angle_2A(angle);
     CB5 2D0A      MOV	R16,R10
     CB6 940E 08C0 CALL	_angle_2A
(0152) 	angle_3A(angle);
     CB8 2D0A      MOV	R16,R10
     CB9 940E 08F9 CALL	_angle_3A
(0153) 	angle_4A(angle);
     CBB 2D0A      MOV	R16,R10
     CBC 940E 0932 CALL	_angle_4A
(0154) 	angle_5A(angle);
     CBE 2D0A      MOV	R16,R10
     CBF 940E 096B CALL	_angle_5A
(0155) 	angle_6A(angle);
     CC1 2D0A      MOV	R16,R10
     CC2 940E 09A4 CALL	_angle_6A
     CC4 90A9      LD	R10,Y+
     CC5 9508      RET
_angle_XB:
  angle                --> R10
     CC6 92AA      ST	R10,-Y
     CC7 2EA0      MOV	R10,R16
(0156) }
(0157) 
(0158) /**
(0159) Sets the angle of all the MOTOR_XB servo
(0160) @param angle : The angle to be set
(0161) */
(0162) void angle_XB(unsigned char angle) {
(0163) 	angle_1B(angle);
     CC8 2D0A      MOV	R16,R10
     CC9 940E 0896 CALL	_angle_1B
(0164) 	angle_2B(angle);
     CCB 2D0A      MOV	R16,R10
     CCC 940E 08CF CALL	_angle_2B
(0165) 	angle_3B(angle);
     CCE 2D0A      MOV	R16,R10
     CCF 940E 0908 CALL	_angle_3B
(0166) 	angle_4B(180 - angle);
     CD1 2C2A      MOV	R2,R10
     CD2 2433      CLR	R3
     CD3 EB04      LDI	R16,0xB4
     CD4 1902      SUB	R16,R2
     CD5 0913      SBC	R17,R3
     CD6 940E 0941 CALL	_angle_4B
(0167) 	angle_5B(180 - angle);
     CD8 2C2A      MOV	R2,R10
     CD9 2433      CLR	R3
     CDA EB04      LDI	R16,0xB4
     CDB 1902      SUB	R16,R2
     CDC 0913      SBC	R17,R3
     CDD 940E 097A CALL	_angle_5B
(0168) 	angle_6B(180 - angle);
     CDF 2C2A      MOV	R2,R10
     CE0 2433      CLR	R3
     CE1 EB04      LDI	R16,0xB4
     CE2 1902      SUB	R16,R2
     CE3 0913      SBC	R17,R3
     CE4 940E 09B3 CALL	_angle_6B
     CE6 90A9      LD	R10,Y+
     CE7 9508      RET
_angle_XC:
  angle                --> R10
     CE8 92AA      ST	R10,-Y
     CE9 2EA0      MOV	R10,R16
(0169) }
(0170) 
(0171) 
(0172) /**
(0173) Sets the angle of all the MOTOR_XC servo
(0174) @param angle : The angle to be set
(0175) */
(0176) void angle_XC(unsigned char angle) {
(0177) 	angle_1C(angle);
     CEA 2D0A      MOV	R16,R10
     CEB 940E 08AB CALL	_angle_1C
(0178) 	angle_2C(angle);
     CED 2D0A      MOV	R16,R10
     CEE 940E 08E4 CALL	_angle_2C
(0179) 	angle_3C(angle);
     CF0 2D0A      MOV	R16,R10
     CF1 940E 091D CALL	_angle_3C
(0180) 	angle_4C(180 - angle);
     CF3 2C2A      MOV	R2,R10
     CF4 2433      CLR	R3
     CF5 EB04      LDI	R16,0xB4
     CF6 1902      SUB	R16,R2
     CF7 0913      SBC	R17,R3
     CF8 940E 0956 CALL	_angle_4C
(0181) 	angle_5C(180 - angle);
     CFA 2C2A      MOV	R2,R10
     CFB 2433      CLR	R3
     CFC EB04      LDI	R16,0xB4
     CFD 1902      SUB	R16,R2
     CFE 0913      SBC	R17,R3
     CFF 940E 098F CALL	_angle_5C
(0182) 	angle_6C(180 - angle);
     D01 2C2A      MOV	R2,R10
     D02 2433      CLR	R3
     D03 EB04      LDI	R16,0xB4
     D04 1902      SUB	R16,R2
     D05 0913      SBC	R17,R3
     D06 940E 09C8 CALL	_angle_6C
     D08 90A9      LD	R10,Y+
     D09 9508      RET
_swap:
  t                    --> R10
  b                    --> R18
  a                    --> R16
     D0A 92AA      ST	R10,-Y
(0183) }
(0184) 
(0185) 
(0186) 
(0187) /**
(0188) Swaps two unsigned char
(0189) */
(0190) void swap(unsigned char *a, unsigned char *b) {
(0191) 	 unsigned char t = *a;
     D0B 01F8      MOVW	R30,R16
     D0C 80A0      LDD	R10,Z+0
(0192) 	 *a = *b;
     D0D 01F9      MOVW	R30,R18
     D0E 8020      LDD	R2,Z+0
     D0F 01F8      MOVW	R30,R16
     D10 8220      STD	Z+0,R2
(0193) 	 *b = t;
     D11 01F9      MOVW	R30,R18
     D12 82A0      STD	Z+0,R10
     D13 90A9      LD	R10,Y+
     D14 9508      RET
(0194) }
(0195) 
(0196) void setAngle(unsigned char arm, unsigned char motor, unsigned char angle) {
(0197) 	 angleArr[arm][motor - 'A'] = angle;
_setAngle:
  angle                --> Y,+0
  motor                --> R18
  arm                  --> R16
     D15 E083      LDI	R24,3
     D16 9F80      MUL	R24,R16
     D17 0110      MOVW	R2,R0
     D18 E583      LDI	R24,0x53
     D19 E092      LDI	R25,2
     D1A 0E28      ADD	R2,R24
     D1B 1E39      ADC	R3,R25
     D1C 2FE2      MOV	R30,R18
     D1D 27FF      CLR	R31
     D1E 54E1      SUBI	R30,0x41
     D1F 40F0      SBCI	R31,0
     D20 0DE2      ADD	R30,R2
     D21 1DF3      ADC	R31,R3
     D22 8008      LDD	R0,Y+0
     D23 8200      STD	Z+0,R0
     D24 9508      RET
(0198) }
(0199) 
(0200) unsigned char getAngle(unsigned char arm, unsigned char motor) {
(0201) 	 return angleArr[arm][motor - 'A'];
_getAngle:
  motor                --> R18
  arm                  --> R16
     D25 E083      LDI	R24,3
     D26 9F80      MUL	R24,R16
     D27 0110      MOVW	R2,R0
     D28 E583      LDI	R24,0x53
     D29 E092      LDI	R25,2
     D2A 0E28      ADD	R2,R24
     D2B 1E39      ADC	R3,R25
     D2C 2FE2      MOV	R30,R18
     D2D 27FF      CLR	R31
     D2E 54E1      SUBI	R30,0x41
     D2F 40F0      SBCI	R31,0
     D30 0DE2      ADD	R30,R2
     D31 1DF3      ADC	R31,R3
     D32 8100      LDD	R16,Z+0
     D33 9508      RET
(0202) }
(0203) 
(0204) 
(0205) /**
(0206) Flips the state of the buzzer
(0207) */
(0208) void buzzer_on_off() {
(0209)      static int flag = 1;
(0210) 	 if(flag) {
_buzzer_on_off:
     D34 9020 020B LDS	R2,hexapod_basic.c:flag
     D36 9030 020C LDS	R3,hexapod_basic.c:flag+1
     D38 2022      TST	R2
     D39 F411      BNE	0x0D3C
     D3A 2033      TST	R3
     D3B F049      BEQ	0x0D45
(0211) 	     buzzer_on();
     D3C 940E 0BA4 CALL	_buzzer_on
(0212) 	 	 flag = 0;
     D3E 2422      CLR	R2
     D3F 2433      CLR	R3
     D40 9230 020C STS	hexapod_basic.c:flag+1,R3
     D42 9220 020B STS	hexapod_basic.c:flag,R2
(0213) 	 }else {
     D44 C008      RJMP	0x0D4D
(0214) 	     buzzer_off();
     D45 940E 0BA6 CALL	_buzzer_off
(0215) 	     flag = 1;  
     D47 E081      LDI	R24,1
     D48 E090      LDI	R25,0
     D49 9390 020C STS	hexapod_basic.c:flag+1,R25
     D4B 9380 020B STS	hexapod_basic.c:flag,R24
(0216) 	 }
     D4D 9508      RET
_angle_change:
  angle1               --> R20
  change               --> R22
  motor                --> R12
  arm                  --> R10
     D4E 940E 13BA CALL	push_xgsetF0FC
     D50 2EC2      MOV	R12,R18
     D51 2EA0      MOV	R10,R16
     D52 9721      SBIW	R28,1
     D53 856B      LDD	R22,Y+11
(0217) }
(0218) 
(0219) /**
(0220) Changes the angle of a servo by change
(0221) Problem with this routine
(0222) */
(0223) void angle_change(unsigned char arm, unsigned char motor, char change) {
(0224)     
(0225) 	unsigned char angle1;
(0226) 	
(0227) 	 if(change + getAngle(arm, motor) < DEGREE_MIN || change + getAngle(arm, motor)  > 240) {
     D54 2D2C      MOV	R18,R12
     D55 2D0A      MOV	R16,R10
     D56 DFCE      RCALL	_getAngle
     D57 2F86      MOV	R24,R22
     D58 0F80      ADD	R24,R16
     D59 3080      CPI	R24,0
     D5A F040      BCS	0x0D63
     D5B 2D2C      MOV	R18,R12
     D5C 2D0A      MOV	R16,R10
     D5D DFC7      RCALL	_getAngle
     D5E 2E26      MOV	R2,R22
     D5F 0E20      ADD	R2,R16
     D60 EF80      LDI	R24,0xF0
     D61 1582      CP	R24,R2
     D62 F410      BCC	0x0D65
(0228) 	 		   angle1 = DEGREE_MIN;
     D63 2744      CLR	R20
(0229) 			   //buzzer_on();
(0230) 	} else if(change + getAngle(arm, motor)  > DEGREE_MAX) {
     D64 C011      RJMP	0x0D76
     D65 2D2C      MOV	R18,R12
     D66 2D0A      MOV	R16,R10
     D67 DFBD      RCALL	_getAngle
     D68 2EE0      MOV	R14,R16
     D69 2E26      MOV	R2,R22
     D6A 0E20      ADD	R2,R16
     D6B EB84      LDI	R24,0xB4
     D6C 1582      CP	R24,R2
     D6D F410      BCC	0x0D70
(0231) 	           angle1 = DEGREE_MAX;
     D6E EB44      LDI	R20,0xB4
(0232) 			   //buzzer_on();
(0233) 	} else {
     D6F C006      RJMP	0x0D76
(0234) 	 		   angle1 = change + getAngle(arm, motor);
     D70 2D2C      MOV	R18,R12
     D71 2D0A      MOV	R16,R10
     D72 DFB2      RCALL	_getAngle
     D73 2EE0      MOV	R14,R16
     D74 2F46      MOV	R20,R22
     D75 0F40      ADD	R20,R16
(0235) 	}
(0236) 	angle(arm, motor, angle1);
     D76 8348      STD	Y+0,R20
     D77 2D2C      MOV	R18,R12
     D78 2D0A      MOV	R16,R10
     D79 DE83      RCALL	_angle
     D7A 9621      ADIW	R28,1
     D7B 940C 13AF JMP	pop_xgsetF0FC
(0237) 	
(0238) }
(0239) 
(0240) 
(0241) /**
(0242) The sets the direction for the angleMirror function
(0243) Used to move two legs with the same angle
(0244) */
(0245) void setMirrorDir(unsigned char dir) {
(0246) 	 dirMirror = dir;
_setMirrorDir:
  dir                  --> R16
     D7D 9300 020A STS	hexapod_basic.c:dirMirror,R16
     D7F 9508      RET
(0247) }
(0248) 
(0249) /**
(0250) Returns the Mirror diricetion
(0251) */
(0252) unsigned char getMirrorDir(void ) {
(0253) 	 return dirMirror;
_getMirrorDir:
     D80 9100 020A LDS	R16,hexapod_basic.c:dirMirror
     D82 9508      RET
_getMirrorArm:
  arr_mirror           --> Y,+0
  arm                  --> R10
     D83 92AA      ST	R10,-Y
     D84 2EA0      MOV	R10,R16
     D85 97A4      SBIW	R28,0x24
(0254) }
(0255) 
(0256) /**
(0257) Returns the arm which mirrors the arm according to the dirMirror
(0258) */
(0259) unsigned char getMirrorArm(unsigned char arm) {
(0260) 		 int arr_mirror[3][6] =  {{LEG_2, LEG_1, LEG_4, LEG_3, LEG_6, LEG_5}, 
     D86 E480      LDI	R24,0x40
     D87 E091      LDI	R25,1
     D88 01FE      MOVW	R30,R28
     D89 E204      LDI	R16,0x24
     D8A E010      LDI	R17,0
     D8B 93FA      ST	R31,-Y
     D8C 93EA      ST	R30,-Y
     D8D 939A      ST	R25,-Y
     D8E 938A      ST	R24,-Y
     D8F 940E 13EF CALL	asgncblkx
(0261) 		 	 				   	{LEG_6, LEG_3, LEG_2, LEG_5, LEG_4, LEG_1}, 
(0262) 								{LEG_4, LEG_5, LEG_6, LEG_1, LEG_2, LEG_3}};
(0263) 		 return arr_mirror[getMirrorDir()][arm - 1];
     D91 DFEE      RCALL	_getMirrorDir
     D92 E08C      LDI	R24,0xC
     D93 9F80      MUL	R24,R16
     D94 0110      MOVW	R2,R0
     D95 01CE      MOVW	R24,R28
     D96 0E28      ADD	R2,R24
     D97 1E39      ADC	R3,R25
     D98 2DEA      MOV	R30,R10
     D99 27FF      CLR	R31
     D9A 9731      SBIW	R30,1
     D9B 0FEE      LSL	R30
     D9C 1FFF      ROL	R31
     D9D 0DE2      ADD	R30,R2
     D9E 1DF3      ADC	R31,R3
     D9F 8100      LDD	R16,Z+0
     DA0 96A4      ADIW	R28,0x24
     DA1 90A9      LD	R10,Y+
     DA2 9508      RET
_angleMirror:
  arm_mirror           --> R10
  angleSet             --> R12
  motor                --> R20
  arm                  --> R14
     DA3 940E 13BC CALL	push_xgset30FC
     DA5 2F42      MOV	R20,R18
     DA6 2EE0      MOV	R14,R16
     DA7 9721      SBIW	R28,1
     DA8 84C9      LDD	R12,Y+9
(0264) }
(0265) 
(0266) 
(0267) /**
(0268) Sets the angle of the arm servo and its Mirror arm to the angle angleSet
(0269) @param arm : Arm of the hexapod
(0270) @param motor : The motor of the hexapod
(0271) @param angleSet :  The angle to be set 
(0272) */
(0273) void angleMirror(unsigned char arm, unsigned char motor, unsigned char angleSet) {
(0274) 	 unsigned char arm_mirror = getMirrorArm(arm);
     DA9 2D0E      MOV	R16,R14
     DAA DFD8      RCALL	_getMirrorArm
     DAB 2EA0      MOV	R10,R16
(0275) 	 angle(arm, motor, angleSet);
     DAC 82C8      STD	Y+0,R12
     DAD 2F24      MOV	R18,R20
     DAE 2D0E      MOV	R16,R14
     DAF DE4D      RCALL	_angle
(0276) 	 if(motor == MOTOR_A)
     DB0 3441      CPI	R20,0x41
     DB1 F459      BNE	0x0DBD
(0277) 	 	 angle(arm_mirror, motor, 180 - angleSet);
     DB2 2C2C      MOV	R2,R12
     DB3 2433      CLR	R3
     DB4 EB84      LDI	R24,0xB4
     DB5 E090      LDI	R25,0
     DB6 1982      SUB	R24,R2
     DB7 0993      SBC	R25,R3
     DB8 8388      STD	Y+0,R24
     DB9 2F24      MOV	R18,R20
     DBA 2D0A      MOV	R16,R10
     DBB DE41      RCALL	_angle
     DBC C004      RJMP	0x0DC1
(0278) 	 else
(0279) 	 	 angle(arm_mirror, motor, angleSet);
     DBD 82C8      STD	Y+0,R12
     DBE 2F24      MOV	R18,R20
     DBF 2D0A      MOV	R16,R10
     DC0 DE3C      RCALL	_angle
     DC1 9621      ADIW	R28,1
     DC2 940C 13A6 JMP	pop_xgset30FC
_angleMirrorChange:
  arm_mirror           --> R10
  angleChange          --> R14
  motor                --> R12
  arm                  --> R20
     DC4 940E 13BC CALL	push_xgset30FC
     DC6 2EC2      MOV	R12,R18
     DC7 2F40      MOV	R20,R16
     DC8 9721      SBIW	R28,1
     DC9 84E9      LDD	R14,Y+9
(0280) 	 	  		  
(0281) }
(0282) 
(0283) /**
(0284) Changes angle of the arm servo and its Mirror arm by the angle angleChange
(0285) @param arm : Arm of the hexapod
(0286) @param motor : The motor of the hexapod
(0287) @param angleChange :  The angle to change by 
(0288) */
(0289) void angleMirrorChange(unsigned char arm, unsigned char motor, char angleChange) {
(0290) 	 unsigned char arm_mirror = getMirrorArm(arm);
     DCA 2F04      MOV	R16,R20
     DCB DFB7      RCALL	_getMirrorArm
     DCC 2EA0      MOV	R10,R16
(0291) 	 angle_change(arm, motor, angleChange);
     DCD 82E8      STD	Y+0,R14
     DCE 2D2C      MOV	R18,R12
     DCF 2F04      MOV	R16,R20
     DD0 DF7D      RCALL	_angle_change
(0292) 	 angle_change(arm_mirror, motor, angleChange);
     DD1 82E8      STD	Y+0,R14
     DD2 2D2C      MOV	R18,R12
     DD3 2D0A      MOV	R16,R10
     DD4 DF79      RCALL	_angle_change
     DD5 9621      ADIW	R28,1
     DD6 940C 13A6 JMP	pop_xgset30FC
_pose:
  dir6                 --> R10
  dir5                 --> Y,+17
  spread_out           --> R12
  step_side            --> R14
  lift                 --> R22
  legs_clock           --> Y,+8
  legs_anticlock       --> Y,+1
  dir4                 --> Y,+16
  dir3                 --> Y,+15
  i                    --> R22
  delay_time           --> R20
  steps                --> Y,+32
  dir2                 --> Y,+30
  dir1                 --> Y,+28
     DD8 940E 1379 CALL	push_arg4
     DDA 940E 13BA CALL	push_xgsetF0FC
     DDC 9762      SBIW	R28,0x12
FILE: D:\BUILDI~1\hexapod_motions.c
(0001) /***
(0002) @author  Srijit Dutt
(0003) Date Sun 07 Nov 2010 02:42:38 PM IST 
(0004) 
(0005) ICCAVR
(0006) 
(0007) hexapod_motions.c : File contains various advanced motion functions for the hexapod
(0008) Please include hexapod_motions.h file to call function from this file
(0009) 
(0010) */
(0011) 
(0012) 
(0013) 
(0014) /*********************************************************************************
(0015) 
(0016)    Copyright (c) 2010, ERTS Lab IIT Bombay erts@cse.iitb.ac.in               -*- c -*-
(0017)    All rights reserved.
(0018) 
(0019)    Redistribution and use in source and binary forms, with or without
(0020)    modification, are permitted provided that the following conditions are met:
(0021) 
(0022)    * Redistributions of source code must retain the above copyright
(0023)      notice, this list of conditions and the following disclaimer.
(0024) 
(0025)    * Redistributions in binary form must reproduce the above copyright
(0026)      notice, this list of conditions and the following disclaimer in
(0027)      the documentation and/or other materials provided with the
(0028)      distribution.
(0029) 
(0030)    * Neither the name of the copyright holders nor the names of
(0031)      contributors may be used to endorse or promote products derived
(0032)      from this software without specific prior written permission.
(0033) 
(0034)    * Source code can be used for academic purpose. 
(0035) 	 For commercial use permission form the author needs to be taken.
(0036) 
(0037)   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
(0038)   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
(0039)   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
(0040)   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
(0041)   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
(0042)   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
(0043)   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
(0044)   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
(0045)   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
(0046)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
(0047)   POSSIBILITY OF SUCH DAMAGE. 
(0048) 
(0049)   Software released under Creative Commence cc by-nc-sa licence.
(0050)   For legal information refer to: 
(0051)   http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode
(0052) 
(0053) ********************************************************************************/
(0054) 
(0055) 
(0056) #include "hexapod_macro.h"
(0057) #include "hexapod_basic.h"
(0058) #include "hexapod.h"
(0059) 
(0060) 
(0061) /**
(0062) The hexapod stands on 4 legs with two legs in the air
(0063) and moves its legs
(0064) @param dir1 : The first of the two legs to be in air 
(0065) @param dir2 : The second leg to be in air 
(0066) The legs should be consecutive
(0067) @param steps : The number of time the legs in the air are moved
(0068) */
(0069) void pose(unsigned char dir1, unsigned char dir2, int steps) {
(0070) 	 
(0071) 	 unsigned char legs_anticlock[] = {0,2,3,6,1,4,5};
     DDD E684      LDI	R24,0x64
     DDE E091      LDI	R25,1
     DDF 01FE      MOVW	R30,R28
     DE0 9631      ADIW	R30,1
     DE1 E007      LDI	R16,7
     DE2 E010      LDI	R17,0
     DE3 93FA      ST	R31,-Y
     DE4 93EA      ST	R30,-Y
     DE5 939A      ST	R25,-Y
     DE6 938A      ST	R24,-Y
     DE7 940E 13EF CALL	asgncblkx
(0072) 	 unsigned char legs_clock[] = {0,4,1,2,5,6,3}; 
     DE9 E68B      LDI	R24,0x6B
     DEA E091      LDI	R25,1
     DEB 01FE      MOVW	R30,R28
     DEC 9638      ADIW	R30,0x8
     DED E007      LDI	R16,7
     DEE E010      LDI	R17,0
     DEF 93FA      ST	R31,-Y
     DF0 93EA      ST	R30,-Y
     DF1 939A      ST	R25,-Y
     DF2 938A      ST	R24,-Y
     DF3 940E 13EF CALL	asgncblkx
(0073) 	 unsigned char dir3 = legs_anticlock[dir2];
     DF5 01CE      MOVW	R24,R28
     DF6 9601      ADIW	R24,1
     DF7 8DEE      LDD	R30,Y+30
     DF8 27FF      CLR	R31
     DF9 0FE8      ADD	R30,R24
     DFA 1FF9      ADC	R31,R25
     DFB 8020      LDD	R2,Z+0
     DFC 862F      STD	Y+15,R2
(0074) 	 unsigned char dir4 = legs_clock[dir1];
     DFD 01CE      MOVW	R24,R28
     DFE 9608      ADIW	R24,0x8
     DFF 8DEC      LDD	R30,Y+28
     E00 27FF      CLR	R31
     E01 0FE8      ADD	R30,R24
     E02 1FF9      ADC	R31,R25
     E03 8020      LDD	R2,Z+0
     E04 8A28      STD	Y+16,R2
(0075) 	 unsigned char dir5 = legs_clock[dir4];
     E05 01CE      MOVW	R24,R28
     E06 9608      ADIW	R24,0x8
     E07 2DE2      MOV	R30,R2
     E08 27FF      CLR	R31
     E09 0FE8      ADD	R30,R24
     E0A 1FF9      ADC	R31,R25
     E0B 8020      LDD	R2,Z+0
     E0C 8A29      STD	Y+17,R2
(0076) 	 unsigned char dir6= legs_anticlock[dir3];
     E0D 01CE      MOVW	R24,R28
     E0E 9601      ADIW	R24,1
     E0F 85EF      LDD	R30,Y+15
     E10 27FF      CLR	R31
     E11 0FE8      ADD	R30,R24
     E12 1FF9      ADC	R31,R25
     E13 80A0      LDD	R10,Z+0
(0077) 	 
(0078) 	 unsigned char lift = 40;
     E14 E268      LDI	R22,0x28
(0079) 	 unsigned char step_side = 50;
     E15 E382      LDI	R24,0x32
     E16 2EE8      MOV	R14,R24
(0080) 	 unsigned char spread_out = 60;
     E17 E38C      LDI	R24,0x3C
     E18 2EC8      MOV	R12,R24
(0081) 	 int delay_time = FIVE_HUNDRED_MSEC;
     E19 EC48      LDI	R20,0xC8
     E1A E050      LDI	R21,0
(0082) 	 int i;
(0083) 	 
(0084) 	 //lifting legs 3 & 4
(0085) 	 angle(dir3, MOTOR_B, lift);
     E1B 8368      STD	Y+0,R22
     E1C E422      LDI	R18,0x42
     E1D 850F      LDD	R16,Y+15
     E1E 940E 0BFD CALL	_angle
(0086) 	 angle(dir4, MOTOR_B, lift);
     E20 8368      STD	Y+0,R22
     E21 E422      LDI	R18,0x42
     E22 8908      LDD	R16,Y+16
     E23 940E 0BFD CALL	_angle
(0087) 	 
(0088) 	 delay(delay_time);
     E25 018A      MOVW	R16,R20
     E26 940E 0BAA CALL	_delay
(0089) 	 
(0090) 	 //moving legs 3 & 4 forward
(0091) 	 angle(dir3, MOTOR_A, 90 - step_side);
     E28 E58A      LDI	R24,0x5A
     E29 198E      SUB	R24,R14
     E2A 8388      STD	Y+0,R24
     E2B E421      LDI	R18,0x41
     E2C 850F      LDD	R16,Y+15
     E2D 940E 0BFD CALL	_angle
(0092) 	 angle(dir4, MOTOR_A, 90 + step_side);
     E2F 2D8E      MOV	R24,R14
     E30 5A86      SUBI	R24,0xA6
     E31 8388      STD	Y+0,R24
     E32 E421      LDI	R18,0x41
     E33 8908      LDD	R16,Y+16
     E34 940E 0BFD CALL	_angle
(0093) 	 angle(dir3, MOTOR_C, 90 + 70);
     E36 EA80      LDI	R24,0xA0
     E37 8388      STD	Y+0,R24
     E38 E423      LDI	R18,0x43
     E39 850F      LDD	R16,Y+15
     E3A 940E 0BFD CALL	_angle
(0094) 	 angle(dir4, MOTOR_C, 90 + 70);
     E3C EA80      LDI	R24,0xA0
     E3D 8388      STD	Y+0,R24
     E3E E423      LDI	R18,0x43
     E3F 8908      LDD	R16,Y+16
     E40 940E 0BFD CALL	_angle
(0095) 
(0096) 	 
(0097) 	 //spreading legs 5 & 6 out
(0098) 	 angle(dir5, MOTOR_C, 90 + spread_out);
     E42 2D8C      MOV	R24,R12
     E43 5A86      SUBI	R24,0xA6
     E44 8388      STD	Y+0,R24
     E45 E423      LDI	R18,0x43
     E46 8909      LDD	R16,Y+17
     E47 940E 0BFD CALL	_angle
(0099) 	 angle(dir6, MOTOR_C, 90 + spread_out);
     E49 2D8C      MOV	R24,R12
     E4A 5A86      SUBI	R24,0xA6
     E4B 8388      STD	Y+0,R24
     E4C E423      LDI	R18,0x43
     E4D 2D0A      MOV	R16,R10
     E4E 940E 0BFD CALL	_angle
(0100) 	 
(0101) 	 delay(delay_time);
     E50 018A      MOVW	R16,R20
     E51 940E 0BAA CALL	_delay
(0102) 	 
(0103) 	 
(0104) 	 //putting down legs 3 & 4
(0105) 	 angle(dir3, MOTOR_B, 180);
     E53 EB84      LDI	R24,0xB4
     E54 8388      STD	Y+0,R24
     E55 E422      LDI	R18,0x42
     E56 850F      LDD	R16,Y+15
     E57 940E 0BFD CALL	_angle
(0106) 	 angle(dir4, MOTOR_B, 180);
     E59 EB84      LDI	R24,0xB4
     E5A 8388      STD	Y+0,R24
     E5B E422      LDI	R18,0x42
     E5C 8908      LDD	R16,Y+16
     E5D 940E 0BFD CALL	_angle
(0107) 
(0108) 	 delay(delay_time);
     E5F 018A      MOVW	R16,R20
     E60 940E 0BAA CALL	_delay
(0109) 	 
(0110) 	 //lifting legs 1 & 2
(0111) 	 angle(dir1, MOTOR_B, 0);
     E62 2422      CLR	R2
     E63 8228      STD	Y+0,R2
     E64 E422      LDI	R18,0x42
     E65 8D0C      LDD	R16,Y+28
     E66 940E 0BFD CALL	_angle
(0112) 	 angle(dir2, MOTOR_B, 0);
     E68 2422      CLR	R2
     E69 8228      STD	Y+0,R2
     E6A E422      LDI	R18,0x42
     E6B 8D0E      LDD	R16,Y+30
     E6C 940E 0BFD CALL	_angle
(0113) 	 
(0114) 	 //aligning legs 1 & 2
(0115) 	 angle(dir1, MOTOR_A, 150);
     E6E E986      LDI	R24,0x96
     E6F 8388      STD	Y+0,R24
     E70 E421      LDI	R18,0x41
     E71 8D0C      LDD	R16,Y+28
     E72 940E 0BFD CALL	_angle
(0116) 	 angle(dir2, MOTOR_A, 30);
     E74 E18E      LDI	R24,0x1E
     E75 8388      STD	Y+0,R24
     E76 E421      LDI	R18,0x41
     E77 8D0E      LDD	R16,Y+30
     E78 940E 0BFD CALL	_angle
(0117) 	 
(0118) 	 
(0119) 	 //shaking legs 1 & 2 in air
(0120) 	 for(i = 0; i < steps; i++) {
     E7A 2766      CLR	R22
     E7B 2777      CLR	R23
     E7C C020      RJMP	0x0E9D
(0121) 	 	   angle(dir1, MOTOR_B, 30);
     E7D E18E      LDI	R24,0x1E
     E7E 8388      STD	Y+0,R24
     E7F E422      LDI	R18,0x42
     E80 8D0C      LDD	R16,Y+28
     E81 940E 0BFD CALL	_angle
(0122) 		   angle(dir2, MOTOR_B, 30);
     E83 E18E      LDI	R24,0x1E
     E84 8388      STD	Y+0,R24
     E85 E422      LDI	R18,0x42
     E86 8D0E      LDD	R16,Y+30
     E87 940E 0BFD CALL	_angle
(0123) 		   
(0124) 		   delay(delay_time);
     E89 018A      MOVW	R16,R20
     E8A 940E 0BAA CALL	_delay
(0125) 		   
(0126) 		   angle(dir1, MOTOR_B, 0);
     E8C 2422      CLR	R2
     E8D 8228      STD	Y+0,R2
     E8E E422      LDI	R18,0x42
     E8F 8D0C      LDD	R16,Y+28
     E90 940E 0BFD CALL	_angle
(0127) 	 	   angle(dir2, MOTOR_B, 0);
     E92 2422      CLR	R2
     E93 8228      STD	Y+0,R2
     E94 E422      LDI	R18,0x42
     E95 8D0E      LDD	R16,Y+30
     E96 940E 0BFD CALL	_angle
(0128) 		   
(0129) 		   delay(delay_time);
     E98 018A      MOVW	R16,R20
     E99 940E 0BAA CALL	_delay
     E9B 5F6F      SUBI	R22,0xFF
     E9C 4F7F      SBCI	R23,0xFF
     E9D A008      LDD	R0,Y+32
     E9E A019      LDD	R1,Y+33
     E9F 1560      CP	R22,R0
     EA0 0571      CPC	R23,R1
     EA1 F2DC      BLT	0x0E7D
     EA2 9662      ADIW	R28,0x12
     EA3 940E 13AF CALL	pop_xgsetF0FC
     EA5 9624      ADIW	R28,4
     EA6 9508      RET
_dance:
  array_opposite       --> Y,+1
  delay_time           --> R10
  dir2_opposite        --> R22
  dir1_opposite        --> R14
  stretch              --> R20
  steps                --> R12
  dir2                 --> Y,+27
  dir1                 --> Y,+25
     EA7 940E 1379 CALL	push_arg4
     EA9 940E 13BA CALL	push_xgsetF0FC
     EAB 972F      SBIW	R28,0xF
     EAC 8CCD      LDD	R12,Y+29
     EAD 8CDE      LDD	R13,Y+30
(0130) 	 }
(0131) 	 
(0132) 	 //resetting to original position
(0133) 	 //servo_calibration();
(0134) }
(0135) 
(0136) 
(0137) /**
(0138) The hexapod moves its weight from legs dir1, dir2 to legs opposite to dir1, dir2 
(0139) steps : The nummber of steps in the dance move
(0140) @param dir1 : Direction of motion
(0141) @param dir2 : Direction of motion
(0142) @param steps : number of steps
(0143) */
(0144) void dance(unsigned char dir1, unsigned char dir2, int steps) {
(0145) 	 int array_opposite[] = {0,6,5,4,3,2,1};
     EAE E782      LDI	R24,0x72
     EAF E091      LDI	R25,1
     EB0 01FE      MOVW	R30,R28
     EB1 9631      ADIW	R30,1
     EB2 E00E      LDI	R16,0xE
     EB3 E010      LDI	R17,0
     EB4 93FA      ST	R31,-Y
     EB5 93EA      ST	R30,-Y
     EB6 939A      ST	R25,-Y
     EB7 938A      ST	R24,-Y
     EB8 940E 13EF CALL	asgncblkx
(0146) 	 unsigned char dir1_opposite = array_opposite[dir1];
     EBA 01CE      MOVW	R24,R28
     EBB 9601      ADIW	R24,1
     EBC 8DE9      LDD	R30,Y+25
     EBD 27FF      CLR	R31
     EBE 0FEE      LSL	R30
     EBF 1FFF      ROL	R31
     EC0 0FE8      ADD	R30,R24
     EC1 1FF9      ADC	R31,R25
     EC2 80E0      LDD	R14,Z+0
(0147) 	 unsigned char dir2_opposite = array_opposite[dir2];
     EC3 01CE      MOVW	R24,R28
     EC4 9601      ADIW	R24,1
     EC5 8DEB      LDD	R30,Y+27
     EC6 27FF      CLR	R31
     EC7 0FEE      LSL	R30
     EC8 1FFF      ROL	R31
     EC9 0FE8      ADD	R30,R24
     ECA 1FF9      ADC	R31,R25
     ECB 8160      LDD	R22,Z+0
(0148) 	 unsigned char stretch = 90;
     ECC E54A      LDI	R20,0x5A
(0149) 	 int delay_time = FIVE_HUNDRED_MSEC;
     ECD EC88      LDI	R24,0xC8
     ECE E090      LDI	R25,0
     ECF 015C      MOVW	R10,R24
     ED0 C072      RJMP	0x0F43
(0150) 	 
(0151) 	 while(steps-- > 0) {
(0152) 	 			   
(0153) 	 	//move towards 6 & 5
(0154) 		angle(dir1, MOTOR_B, 90 + stretch);
     ED1 2F84      MOV	R24,R20
     ED2 5A86      SUBI	R24,0xA6
     ED3 8388      STD	Y+0,R24
     ED4 E422      LDI	R18,0x42
     ED5 8D09      LDD	R16,Y+25
     ED6 940E 0BFD CALL	_angle
(0155) 	 	angle(dir1, MOTOR_C, 90 + 90);
     ED8 EB84      LDI	R24,0xB4
     ED9 8388      STD	Y+0,R24
     EDA E423      LDI	R18,0x43
     EDB 8D09      LDD	R16,Y+25
     EDC 940E 0BFD CALL	_angle
(0156) 	 	angle(dir1_opposite, MOTOR_B, 90 - stretch); 
     EDE E58A      LDI	R24,0x5A
     EDF 1B84      SUB	R24,R20
     EE0 8388      STD	Y+0,R24
     EE1 E422      LDI	R18,0x42
     EE2 2D0E      MOV	R16,R14
     EE3 940E 0BFD CALL	_angle
(0157) 	 	angle(dir1_opposite, MOTOR_C, 90 - stretch);	 
     EE5 E58A      LDI	R24,0x5A
     EE6 1B84      SUB	R24,R20
     EE7 8388      STD	Y+0,R24
     EE8 E423      LDI	R18,0x43
     EE9 2D0E      MOV	R16,R14
     EEA 940E 0BFD CALL	_angle
(0158) 	 	angle(dir2, MOTOR_B, 90 + stretch);
     EEC 2F84      MOV	R24,R20
     EED 5A86      SUBI	R24,0xA6
     EEE 8388      STD	Y+0,R24
     EEF E422      LDI	R18,0x42
     EF0 8D0B      LDD	R16,Y+27
     EF1 940E 0BFD CALL	_angle
(0159) 	 	angle(dir2, MOTOR_C, 90 + 90);
     EF3 EB84      LDI	R24,0xB4
     EF4 8388      STD	Y+0,R24
     EF5 E423      LDI	R18,0x43
     EF6 8D0B      LDD	R16,Y+27
     EF7 940E 0BFD CALL	_angle
(0160) 	 	angle(dir2_opposite, MOTOR_B, 90 - stretch); 
     EF9 E58A      LDI	R24,0x5A
     EFA 1B84      SUB	R24,R20
     EFB 8388      STD	Y+0,R24
     EFC E422      LDI	R18,0x42
     EFD 2F06      MOV	R16,R22
     EFE 940E 0BFD CALL	_angle
(0161) 	 	angle(dir2_opposite, MOTOR_C, 90 - stretch);
     F00 E58A      LDI	R24,0x5A
     F01 1B84      SUB	R24,R20
     F02 8388      STD	Y+0,R24
     F03 E423      LDI	R18,0x43
     F04 2F06      MOV	R16,R22
     F05 940E 0BFD CALL	_angle
(0162) 		
(0163) 		//delay
(0164) 		delay(delay_time);
     F07 0185      MOVW	R16,R10
     F08 940E 0BAA CALL	_delay
(0165) 		
(0166) 		
(0167) 		//move towards 1 & 2
(0168) 		angle(dir1_opposite, MOTOR_B, 90 + stretch);
     F0A 2F84      MOV	R24,R20
     F0B 5A86      SUBI	R24,0xA6
     F0C 8388      STD	Y+0,R24
     F0D E422      LDI	R18,0x42
     F0E 2D0E      MOV	R16,R14
     F0F 940E 0BFD CALL	_angle
(0169) 	 	angle(dir1_opposite, MOTOR_C, 90 + 90);
     F11 EB84      LDI	R24,0xB4
     F12 8388      STD	Y+0,R24
     F13 E423      LDI	R18,0x43
     F14 2D0E      MOV	R16,R14
     F15 940E 0BFD CALL	_angle
(0170) 	 	angle(dir1, MOTOR_B, 90 - stretch); 
     F17 E58A      LDI	R24,0x5A
     F18 1B84      SUB	R24,R20
     F19 8388      STD	Y+0,R24
     F1A E422      LDI	R18,0x42
     F1B 8D09      LDD	R16,Y+25
     F1C 940E 0BFD CALL	_angle
(0171) 	 	angle(dir1, MOTOR_C, 90 - stretch);	 
     F1E E58A      LDI	R24,0x5A
     F1F 1B84      SUB	R24,R20
     F20 8388      STD	Y+0,R24
     F21 E423      LDI	R18,0x43
     F22 8D09      LDD	R16,Y+25
     F23 940E 0BFD CALL	_angle
(0172) 	 	angle(dir2_opposite, MOTOR_B, 90 + stretch);
     F25 2F84      MOV	R24,R20
     F26 5A86      SUBI	R24,0xA6
     F27 8388      STD	Y+0,R24
     F28 E422      LDI	R18,0x42
     F29 2F06      MOV	R16,R22
     F2A 940E 0BFD CALL	_angle
(0173) 	 	angle(dir2_opposite, MOTOR_C, 90 + 90);
     F2C EB84      LDI	R24,0xB4
     F2D 8388      STD	Y+0,R24
     F2E E423      LDI	R18,0x43
     F2F 2F06      MOV	R16,R22
     F30 940E 0BFD CALL	_angle
(0174) 	 	angle(dir2, MOTOR_B, 90 - stretch); 
     F32 E58A      LDI	R24,0x5A
     F33 1B84      SUB	R24,R20
     F34 8388      STD	Y+0,R24
     F35 E422      LDI	R18,0x42
     F36 8D0B      LDD	R16,Y+27
     F37 940E 0BFD CALL	_angle
(0175) 	 	angle(dir2, MOTOR_C, 90 - stretch);
     F39 E58A      LDI	R24,0x5A
     F3A 1B84      SUB	R24,R20
     F3B 8388      STD	Y+0,R24
     F3C E423      LDI	R18,0x43
     F3D 8D0B      LDD	R16,Y+27
     F3E 940E 0BFD CALL	_angle
(0176) 		
(0177) 		
(0178) 		//delay
(0179) 		delay(delay_time);
     F40 0185      MOVW	R16,R10
     F41 940E 0BAA CALL	_delay
     F43 0126      MOVW	R4,R12
     F44 01C2      MOVW	R24,R4
     F45 9701      SBIW	R24,1
     F46 016C      MOVW	R12,R24
     F47 2422      CLR	R2
     F48 2433      CLR	R3
     F49 1424      CP	R2,R4
     F4A 0435      CPC	R3,R5
     F4B F40C      BGE	0x0F4D
     F4C CF84      RJMP	0x0ED1
     F4D 962F      ADIW	R28,0xF
     F4E 940E 13AF CALL	pop_xgsetF0FC
     F50 9624      ADIW	R28,4
     F51 9508      RET
_sway:
  array_opposite       --> Y,+15
  delay_time           --> R10
  legs_clock           --> Y,+8
  legs_anticlock       --> Y,+1
  dir2_opposite        --> R20
  dir1_opposite        --> R14
  dir_centre_opposite  --> R12
  dir_centre           --> Y,+31
  dir2                 --> Y,+30
  dir1                 --> Y,+29
  stretch              --> R22
  movement             --> Y,+44
  steps                --> Y,+42
     F52 940E 1379 CALL	push_arg4
     F54 940E 13BA CALL	push_xgsetF0FC
     F56 97A0      SBIW	R28,0x20
(0180) 	}	
(0181) }
(0182) 
(0183) /**
(0184) Servo control the hexapod shifts its weight clockwise
(0185) @param steps : number of steps to be carried out
(0186) @param movement : clockwise or anticlockwise
(0187) */
(0188) void sway(int steps, unsigned char movement) {
(0189) 	 int array_opposite[] = {0,6,5,4,3,2,1};
     F57 E880      LDI	R24,0x80
     F58 E091      LDI	R25,1
     F59 01FE      MOVW	R30,R28
     F5A 963F      ADIW	R30,0xF
     F5B E00E      LDI	R16,0xE
     F5C E010      LDI	R17,0
     F5D 93FA      ST	R31,-Y
     F5E 93EA      ST	R30,-Y
     F5F 939A      ST	R25,-Y
     F60 938A      ST	R24,-Y
     F61 940E 13EF CALL	asgncblkx
(0190) 	 unsigned char legs_anticlock[] = {0,2,3,6,1,4,5};
     F63 E88E      LDI	R24,0x8E
     F64 E091      LDI	R25,1
     F65 01FE      MOVW	R30,R28
     F66 9631      ADIW	R30,1
     F67 E007      LDI	R16,7
     F68 E010      LDI	R17,0
     F69 93FA      ST	R31,-Y
     F6A 93EA      ST	R30,-Y
     F6B 939A      ST	R25,-Y
     F6C 938A      ST	R24,-Y
     F6D 940E 13EF CALL	asgncblkx
(0191) 	 unsigned char legs_clock[] = {0,4,1,2,5,6,3};
     F6F E985      LDI	R24,0x95
     F70 E091      LDI	R25,1
     F71 01FE      MOVW	R30,R28
     F72 9638      ADIW	R30,0x8
     F73 E007      LDI	R16,7
     F74 E010      LDI	R17,0
     F75 93FA      ST	R31,-Y
     F76 93EA      ST	R30,-Y
     F77 939A      ST	R25,-Y
     F78 938A      ST	R24,-Y
     F79 940E 13EF CALL	asgncblkx
(0192) 	 unsigned char dir1 = LEG_1;
     F7B 2400      CLR	R0
     F7C 9403      INC	R0
     F7D 8E0D      STD	Y+29,R0
(0193) 	 unsigned char dir2  = LEG_2;
     F7E E082      LDI	R24,2
     F7F 8F8E      STD	Y+30,R24
(0194) 	 unsigned char dir_centre = LEG_3;
     F80 E083      LDI	R24,3
     F81 8F8F      STD	Y+31,R24
(0195) 	 unsigned char dir_centre_opposite  = LEG_4;
     F82 E084      LDI	R24,4
     F83 2EC8      MOV	R12,R24
(0196) 	 unsigned char dir1_opposite = array_opposite[dir1];
     F84 01CE      MOVW	R24,R28
     F85 960F      ADIW	R24,0xF
     F86 8DED      LDD	R30,Y+29
     F87 27FF      CLR	R31
     F88 0FEE      LSL	R30
     F89 1FFF      ROL	R31
     F8A 0FE8      ADD	R30,R24
     F8B 1FF9      ADC	R31,R25
     F8C 80E0      LDD	R14,Z+0
(0197) 	 unsigned char dir2_opposite = array_opposite[dir2];
     F8D 01CE      MOVW	R24,R28
     F8E 960F      ADIW	R24,0xF
     F8F 8DEE      LDD	R30,Y+30
     F90 27FF      CLR	R31
     F91 0FEE      LSL	R30
     F92 1FFF      ROL	R31
     F93 0FE8      ADD	R30,R24
     F94 1FF9      ADC	R31,R25
     F95 8140      LDD	R20,Z+0
(0198) 	 unsigned char stretch = 90;
     F96 E56A      LDI	R22,0x5A
(0199) 	 int delay_time = TWO_HUNDRED_FIFTY_MSEC;
     F97 E684      LDI	R24,0x64
     F98 E090      LDI	R25,0
     F99 015C      MOVW	R10,R24
     F9A C0B0      RJMP	0x104B
(0200) 	 
(0201) 	 while(steps-- > 0) {
(0202) 	 			   
(0203) 	 	//move towards 6 & 5 opposite legs
(0204) 		angle(dir1, MOTOR_B, 90 + stretch);
     F9B 2F86      MOV	R24,R22
     F9C 5A86      SUBI	R24,0xA6
     F9D 8388      STD	Y+0,R24
     F9E E422      LDI	R18,0x42
     F9F 8D0D      LDD	R16,Y+29
     FA0 940E 0BFD CALL	_angle
(0205) 	 	angle(dir1, MOTOR_C, 90 + 90);
     FA2 EB84      LDI	R24,0xB4
     FA3 8388      STD	Y+0,R24
     FA4 E423      LDI	R18,0x43
     FA5 8D0D      LDD	R16,Y+29
     FA6 940E 0BFD CALL	_angle
(0206) 	 	angle(dir1_opposite, MOTOR_B, 90 - stretch); 
     FA8 E58A      LDI	R24,0x5A
     FA9 1B86      SUB	R24,R22
     FAA 8388      STD	Y+0,R24
     FAB E422      LDI	R18,0x42
     FAC 2D0E      MOV	R16,R14
     FAD 940E 0BFD CALL	_angle
(0207) 	 	angle(dir1_opposite, MOTOR_C, 90 - stretch);	 
     FAF E58A      LDI	R24,0x5A
     FB0 1B86      SUB	R24,R22
     FB1 8388      STD	Y+0,R24
     FB2 E423      LDI	R18,0x43
     FB3 2D0E      MOV	R16,R14
     FB4 940E 0BFD CALL	_angle
(0208) 	 	angle(dir2, MOTOR_B, 90 + stretch);
     FB6 2F86      MOV	R24,R22
     FB7 5A86      SUBI	R24,0xA6
     FB8 8388      STD	Y+0,R24
     FB9 E422      LDI	R18,0x42
     FBA 8D0E      LDD	R16,Y+30
     FBB 940E 0BFD CALL	_angle
(0209) 	 	angle(dir2, MOTOR_C, 90 + 90);
     FBD EB84      LDI	R24,0xB4
     FBE 8388      STD	Y+0,R24
     FBF E423      LDI	R18,0x43
     FC0 8D0E      LDD	R16,Y+30
     FC1 940E 0BFD CALL	_angle
(0210) 	 	angle(dir2_opposite, MOTOR_B, 90 - stretch); 
     FC3 E58A      LDI	R24,0x5A
     FC4 1B86      SUB	R24,R22
     FC5 8388      STD	Y+0,R24
     FC6 E422      LDI	R18,0x42
     FC7 2F04      MOV	R16,R20
     FC8 940E 0BFD CALL	_angle
(0211) 	 	angle(dir2_opposite, MOTOR_C, 90 - stretch);
     FCA E58A      LDI	R24,0x5A
     FCB 1B86      SUB	R24,R22
     FCC 8388      STD	Y+0,R24
     FCD E423      LDI	R18,0x43
     FCE 2F04      MOV	R16,R20
     FCF 940E 0BFD CALL	_angle
(0212) 		
(0213) 		//reset leg 3 & 4 centre legs
(0214) 		angle(dir_centre, MOTOR_B, 90);
     FD1 E58A      LDI	R24,0x5A
     FD2 8388      STD	Y+0,R24
     FD3 E422      LDI	R18,0x42
     FD4 8D0F      LDD	R16,Y+31
     FD5 940E 0BFD CALL	_angle
(0215) 		angle(dir_centre_opposite, MOTOR_B, 90);	
     FD7 E58A      LDI	R24,0x5A
     FD8 8388      STD	Y+0,R24
     FD9 E422      LDI	R18,0x42
     FDA 2D0C      MOV	R16,R12
     FDB 940E 0BFD CALL	_angle
(0216) 		angle(dir_centre, MOTOR_C, 90);
     FDD E58A      LDI	R24,0x5A
     FDE 8388      STD	Y+0,R24
     FDF E423      LDI	R18,0x43
     FE0 8D0F      LDD	R16,Y+31
     FE1 940E 0BFD CALL	_angle
(0217) 		angle(dir_centre_opposite, MOTOR_C, 90);
     FE3 E58A      LDI	R24,0x5A
     FE4 8388      STD	Y+0,R24
     FE5 E423      LDI	R18,0x43
     FE6 2D0C      MOV	R16,R12
     FE7 940E 0BFD CALL	_angle
(0218) 		
(0219) 		//delay
(0220) 		delay(delay_time);
     FE9 0185      MOVW	R16,R10
     FEA 940E 0BAA CALL	_delay
(0221) 		
(0222) 		//update legs
(0223) 		if(movement == CLOCK_WISE) {
     FEC A58C      LDD	R24,Y+44
     FED 3081      CPI	R24,1
     FEE F009      BEQ	0x0FF0
     FEF C02E      RJMP	0x101E
(0224) 			dir1 = legs_clock[dir1];
     FF0 01CE      MOVW	R24,R28
     FF1 9608      ADIW	R24,0x8
     FF2 8DED      LDD	R30,Y+29
     FF3 27FF      CLR	R31
     FF4 0FE8      ADD	R30,R24
     FF5 1FF9      ADC	R31,R25
     FF6 8020      LDD	R2,Z+0
     FF7 8E2D      STD	Y+29,R2
(0225) 			dir2 = legs_clock[dir2];
     FF8 01CE      MOVW	R24,R28
     FF9 9608      ADIW	R24,0x8
     FFA 8DEE      LDD	R30,Y+30
     FFB 27FF      CLR	R31
     FFC 0FE8      ADD	R30,R24
     FFD 1FF9      ADC	R31,R25
     FFE 8020      LDD	R2,Z+0
     FFF 8E2E      STD	Y+30,R2
(0226) 			dir1_opposite = legs_clock[dir1_opposite];
    1000 01CE      MOVW	R24,R28
    1001 9608      ADIW	R24,0x8
    1002 2DEE      MOV	R30,R14
    1003 27FF      CLR	R31
    1004 0FE8      ADD	R30,R24
    1005 1FF9      ADC	R31,R25
    1006 80E0      LDD	R14,Z+0
(0227) 			dir2_opposite = legs_clock[dir2_opposite];
    1007 01CE      MOVW	R24,R28
    1008 9608      ADIW	R24,0x8
    1009 2FE4      MOV	R30,R20
    100A 27FF      CLR	R31
    100B 0FE8      ADD	R30,R24
    100C 1FF9      ADC	R31,R25
    100D 8140      LDD	R20,Z+0
(0228) 			dir_centre = legs_clock[dir_centre];
    100E 01CE      MOVW	R24,R28
    100F 9608      ADIW	R24,0x8
    1010 8DEF      LDD	R30,Y+31
    1011 27FF      CLR	R31
    1012 0FE8      ADD	R30,R24
    1013 1FF9      ADC	R31,R25
    1014 8020      LDD	R2,Z+0
    1015 8E2F      STD	Y+31,R2
(0229) 			dir_centre_opposite = legs_clock[dir_centre_opposite];
    1016 01CE      MOVW	R24,R28
    1017 9608      ADIW	R24,0x8
    1018 2DEC      MOV	R30,R12
    1019 27FF      CLR	R31
    101A 0FE8      ADD	R30,R24
    101B 1FF9      ADC	R31,R25
    101C 80C0      LDD	R12,Z+0
(0230) 		} else {
    101D C02D      RJMP	0x104B
(0231) 			dir1 = legs_anticlock[dir1];
    101E 01CE      MOVW	R24,R28
    101F 9601      ADIW	R24,1
    1020 8DED      LDD	R30,Y+29
    1021 27FF      CLR	R31
    1022 0FE8      ADD	R30,R24
    1023 1FF9      ADC	R31,R25
    1024 8020      LDD	R2,Z+0
    1025 8E2D      STD	Y+29,R2
(0232) 			dir2 = legs_anticlock[dir2];
    1026 01CE      MOVW	R24,R28
    1027 9601      ADIW	R24,1
    1028 8DEE      LDD	R30,Y+30
    1029 27FF      CLR	R31
    102A 0FE8      ADD	R30,R24
    102B 1FF9      ADC	R31,R25
    102C 8020      LDD	R2,Z+0
    102D 8E2E      STD	Y+30,R2
(0233) 			dir1_opposite = legs_anticlock[dir1_opposite];
    102E 01CE      MOVW	R24,R28
    102F 9601      ADIW	R24,1
    1030 2DEE      MOV	R30,R14
    1031 27FF      CLR	R31
    1032 0FE8      ADD	R30,R24
    1033 1FF9      ADC	R31,R25
    1034 80E0      LDD	R14,Z+0
(0234) 			dir2_opposite = legs_anticlock[dir2_opposite];
    1035 01CE      MOVW	R24,R28
    1036 9601      ADIW	R24,1
    1037 2FE4      MOV	R30,R20
    1038 27FF      CLR	R31
    1039 0FE8      ADD	R30,R24
    103A 1FF9      ADC	R31,R25
    103B 8140      LDD	R20,Z+0
(0235) 			dir_centre = legs_anticlock[dir_centre];
    103C 01CE      MOVW	R24,R28
    103D 9601      ADIW	R24,1
    103E 8DEF      LDD	R30,Y+31
    103F 27FF      CLR	R31
    1040 0FE8      ADD	R30,R24
    1041 1FF9      ADC	R31,R25
    1042 8020      LDD	R2,Z+0
    1043 8E2F      STD	Y+31,R2
(0236) 			dir_centre_opposite = legs_anticlock[dir_centre_opposite];
    1044 01CE      MOVW	R24,R28
    1045 9601      ADIW	R24,1
    1046 2DEC      MOV	R30,R12
    1047 27FF      CLR	R31
    1048 0FE8      ADD	R30,R24
    1049 1FF9      ADC	R31,R25
    104A 80C0      LDD	R12,Z+0
    104B A44A      LDD	R4,Y+42
    104C A45B      LDD	R5,Y+43
    104D 01C2      MOVW	R24,R4
    104E 9701      SBIW	R24,1
    104F A79B      STD	Y+43,R25
    1050 A78A      STD	Y+42,R24
    1051 2422      CLR	R2
    1052 2433      CLR	R3
    1053 1424      CP	R2,R4
    1054 0435      CPC	R3,R5
    1055 F40C      BGE	0x1057
    1056 CF44      RJMP	0x0F9B
    1057 96A0      ADIW	R28,0x20
    1058 940E 13AF CALL	pop_xgsetF0FC
    105A 9624      ADIW	R28,4
    105B 9508      RET
_climb:
  lift                 --> R20
  delay_time2          --> R22
  delay_time1          --> R20
    105C 940E 13C5 CALL	push_xgsetF000
    105E 9721      SBIW	R28,1
(0237) 		}
(0238) 	}	
(0239) }
(0240) 
(0241) /**
(0242) Used to make the hexapod climb steps
(0243) */
(0244) void climb() {
(0245) 	 unsigned char lift = 50;
(0246) 	 int delay_time1  =  FIVE_HUNDRED_MSEC;
    105F EC48      LDI	R20,0xC8
    1060 E050      LDI	R21,0
(0247) 	 int delay_time2 = ONE_SEC;
    1061 E960      LDI	R22,0x90
    1062 E071      LDI	R23,1
(0248) 	 
(0249) 	 setMirrorDir(DIR_MIRROR_LEG_1_2);
    1063 2700      CLR	R16
    1064 940E 0D7D CALL	_setMirrorDir
(0250) 	 
(0251) 	 /* ---increase bot height --- */
(0252) 	 angleMirror(LEG_1, MOTOR_B, 180);
    1066 EB84      LDI	R24,0xB4
    1067 8388      STD	Y+0,R24
    1068 E422      LDI	R18,0x42
    1069 E030      LDI	R19,0
    106A E001      LDI	R16,1
    106B E010      LDI	R17,0
    106C 940E 0DA3 CALL	_angleMirror
(0253) 	 angleMirror(LEG_1, MOTOR_C, 180);
    106E EB84      LDI	R24,0xB4
    106F 8388      STD	Y+0,R24
    1070 E423      LDI	R18,0x43
    1071 E030      LDI	R19,0
    1072 E001      LDI	R16,1
    1073 E010      LDI	R17,0
    1074 940E 0DA3 CALL	_angleMirror
(0254) 	 
(0255) 	 angleMirror(LEG_4, MOTOR_B, 180);
    1076 EB84      LDI	R24,0xB4
    1077 8388      STD	Y+0,R24
    1078 E422      LDI	R18,0x42
    1079 E030      LDI	R19,0
    107A E004      LDI	R16,4
    107B E010      LDI	R17,0
    107C 940E 0DA3 CALL	_angleMirror
(0256) 	 angleMirror(LEG_4, MOTOR_C, 180);
    107E EB84      LDI	R24,0xB4
    107F 8388      STD	Y+0,R24
    1080 E423      LDI	R18,0x43
    1081 E030      LDI	R19,0
    1082 E004      LDI	R16,4
    1083 E010      LDI	R17,0
    1084 940E 0DA3 CALL	_angleMirror
(0257) 	 
(0258) 	 angleMirror(LEG_5, MOTOR_B, 180);
    1086 EB84      LDI	R24,0xB4
    1087 8388      STD	Y+0,R24
    1088 E422      LDI	R18,0x42
    1089 E030      LDI	R19,0
    108A E005      LDI	R16,5
    108B E010      LDI	R17,0
    108C 940E 0DA3 CALL	_angleMirror
(0259) 	 angleMirror(LEG_5, MOTOR_C, 180);
    108E EB84      LDI	R24,0xB4
    108F 8388      STD	Y+0,R24
    1090 E423      LDI	R18,0x43
    1091 E030      LDI	R19,0
    1092 E005      LDI	R16,5
    1093 E010      LDI	R17,0
    1094 940E 0DA3 CALL	_angleMirror
(0260) 	 
(0261) 	 delay(delay_time1);
    1096 018A      MOVW	R16,R20
    1097 940E 0BAA CALL	_delay
(0262) 	 
(0263) 	 
(0264) 	 /* ---- Thrust the body of the robot forward ----*/
(0265) 	 
(0266) 	 //pick up leg 3 & 4
(0267) 	 angleMirror(LEG_4, MOTOR_B, 90);
    1099 E58A      LDI	R24,0x5A
    109A 8388      STD	Y+0,R24
    109B E422      LDI	R18,0x42
    109C E030      LDI	R19,0
    109D E004      LDI	R16,4
    109E E010      LDI	R17,0
    109F 940E 0DA3 CALL	_angleMirror
(0268) 	 	 
(0269) 	 delay(delay_time1);
    10A1 018A      MOVW	R16,R20
    10A2 940E 0BAA CALL	_delay
(0270) 		
(0271) 		
(0272) 	 //Leg 3 moves more than leg 4 bot goes towards left 	 
(0273) 	 //move leg 3 & 4 in air
(0274) 	 //angleMirror(LEG_4, MOTOR_A, 180);
(0275) 	 angle(LEG_4, MOTOR_A, 180);
    10A4 EB84      LDI	R24,0xB4
    10A5 8388      STD	Y+0,R24
    10A6 E421      LDI	R18,0x41
    10A7 E004      LDI	R16,4
    10A8 940E 0BFD CALL	_angle
(0276) 	 angle(LEG_3, MOTOR_A, 20);
    10AA E184      LDI	R24,0x14
    10AB 8388      STD	Y+0,R24
    10AC E421      LDI	R18,0x41
    10AD E003      LDI	R16,3
    10AE 940E 0BFD CALL	_angle
(0277) 	 
(0278) 	 delay(delay_time2);
    10B0 018B      MOVW	R16,R22
    10B1 940E 0BAA CALL	_delay
(0279) 	 	 
(0280) 	 //put leg 3 & 4 down
(0281) 	 angleMirror(LEG_4, MOTOR_B, 180);
    10B3 EB84      LDI	R24,0xB4
    10B4 8388      STD	Y+0,R24
    10B5 E422      LDI	R18,0x42
    10B6 E030      LDI	R19,0
    10B7 E004      LDI	R16,4
    10B8 E010      LDI	R17,0
    10B9 940E 0DA3 CALL	_angleMirror
(0282) 	 
(0283) 	 delay(delay_time1);
    10BB 018A      MOVW	R16,R20
    10BC 940E 0BAA CALL	_delay
(0284) 	 
(0285) 	 //move legs 1 & 2	 
(0286) 	 angleMirror(LEG_1, MOTOR_A, 30);
    10BE E18E      LDI	R24,0x1E
    10BF 8388      STD	Y+0,R24
    10C0 E421      LDI	R18,0x41
    10C1 E030      LDI	R19,0
    10C2 E001      LDI	R16,1
    10C3 E010      LDI	R17,0
    10C4 940E 0DA3 CALL	_angleMirror
(0287) 
(0288) 	 delay(delay_time1);
    10C6 018A      MOVW	R16,R20
    10C7 940E 0BAA CALL	_delay
(0289) 	 
(0290) 	 //pick up leg 1 & 2
(0291) 	 angleMirror(LEG_1, MOTOR_B, 0);
    10C9 2422      CLR	R2
    10CA 8228      STD	Y+0,R2
    10CB E422      LDI	R18,0x42
    10CC E030      LDI	R19,0
    10CD E001      LDI	R16,1
    10CE E010      LDI	R17,0
    10CF 940E 0DA3 CALL	_angleMirror
(0292) 	 angleMirror(LEG_1, MOTOR_C, 180);
    10D1 EB84      LDI	R24,0xB4
    10D2 8388      STD	Y+0,R24
    10D3 E423      LDI	R18,0x43
    10D4 E030      LDI	R19,0
    10D5 E001      LDI	R16,1
    10D6 E010      LDI	R17,0
    10D7 940E 0DA3 CALL	_angleMirror
(0293) 	 
(0294) 	 delay(delay_time2);
    10D9 018B      MOVW	R16,R22
    10DA 940E 0BAA CALL	_delay
(0295) 	 
(0296) 	 //move legs 1 & 2 in air
(0297) 	 angleMirror(LEG_1, MOTOR_A, 150);
    10DC E986      LDI	R24,0x96
    10DD 8388      STD	Y+0,R24
    10DE E421      LDI	R18,0x41
    10DF E030      LDI	R19,0
    10E0 E001      LDI	R16,1
    10E1 E010      LDI	R17,0
    10E2 940E 0DA3 CALL	_angleMirror
(0298) 	 
(0299) 	 delay(delay_time1);
    10E4 018A      MOVW	R16,R20
    10E5 940E 0BAA CALL	_delay
(0300) 	 
(0301) 	 /*---- Bot pushes itself on the platform -- */
(0302) 	 
(0303) 	 //move body on leg 3 & 4
(0304) 	 angleMirror(LEG_4, MOTOR_A, 0);
    10E7 2422      CLR	R2
    10E8 8228      STD	Y+0,R2
    10E9 E421      LDI	R18,0x41
    10EA E030      LDI	R19,0
    10EB E004      LDI	R16,4
    10EC E010      LDI	R17,0
    10ED 940E 0DA3 CALL	_angleMirror
(0305) 	 
(0306) 	 delay(ONE_SEC);
    10EF E900      LDI	R16,0x90
    10F0 E011      LDI	R17,1
    10F1 940E 0BAA CALL	_delay
(0307) 	 
(0308) 	 // move leg 1 & 2
(0309) 	 angleMirror(LEG_1, MOTOR_B, 50); //tune for height
    10F3 E382      LDI	R24,0x32
    10F4 8388      STD	Y+0,R24
    10F5 E422      LDI	R18,0x42
    10F6 E030      LDI	R19,0
    10F7 E001      LDI	R16,1
    10F8 E010      LDI	R17,0
    10F9 940E 0DA3 CALL	_angleMirror
(0310) 	 angleMirror(LEG_1, MOTOR_C, 90); //tune this too
    10FB E58A      LDI	R24,0x5A
    10FC 8388      STD	Y+0,R24
    10FD E423      LDI	R18,0x43
    10FE E030      LDI	R19,0
    10FF E001      LDI	R16,1
    1100 E010      LDI	R17,0
    1101 940E 0DA3 CALL	_angleMirror
(0311) 	 
(0312) 	 delay(delay_time1);
    1103 018A      MOVW	R16,R20
    1104 940E 0BAA CALL	_delay
(0313) 	 
(0314) 	 //pick up 3&4
(0315) 	 angleMirror(LEG_4, MOTOR_B, 0);
    1106 2422      CLR	R2
    1107 8228      STD	Y+0,R2
    1108 E422      LDI	R18,0x42
    1109 E030      LDI	R19,0
    110A E004      LDI	R16,4
    110B E010      LDI	R17,0
    110C 940E 0DA3 CALL	_angleMirror
(0316) 	 angleMirror(LEG_4, MOTOR_C, 180);
    110E EB84      LDI	R24,0xB4
    110F 8388      STD	Y+0,R24
    1110 E423      LDI	R18,0x43
    1111 E030      LDI	R19,0
    1112 E004      LDI	R16,4
    1113 E010      LDI	R17,0
    1114 940E 0DA3 CALL	_angleMirror
(0317) 	 
(0318) 	 delay(delay_time1);
    1116 018A      MOVW	R16,R20
    1117 940E 0BAA CALL	_delay
(0319) 	 
(0320) 	 //moving leg 3&4 in air
(0321) 	 angleMirror(LEG_4, MOTOR_A, 180);
    1119 EB84      LDI	R24,0xB4
    111A 8388      STD	Y+0,R24
    111B E421      LDI	R18,0x41
    111C E030      LDI	R19,0
    111D E004      LDI	R16,4
    111E E010      LDI	R17,0
    111F 940E 0DA3 CALL	_angleMirror
(0322) 	 
(0323) 	 delay(delay_time1);
    1121 018A      MOVW	R16,R20
    1122 940E 0BAA CALL	_delay
(0324) 	 
(0325) 	 //make leg 3 &4 touch ground
(0326) 	 angleMirror(LEG_4, MOTOR_B, 50);
    1124 E382      LDI	R24,0x32
    1125 8388      STD	Y+0,R24
    1126 E422      LDI	R18,0x42
    1127 E030      LDI	R19,0
    1128 E004      LDI	R16,4
    1129 E010      LDI	R17,0
    112A 940E 0DA3 CALL	_angleMirror
(0327) 	 angleMirror(LEG_4, MOTOR_C, 50);
    112C E382      LDI	R24,0x32
    112D 8388      STD	Y+0,R24
    112E E423      LDI	R18,0x43
    112F E030      LDI	R19,0
    1130 E004      LDI	R16,4
    1131 E010      LDI	R17,0
    1132 940E 0DA3 CALL	_angleMirror
(0328) 	 
(0329) 	 
(0330) 	 delay(delay_time1);
    1134 018A      MOVW	R16,R20
    1135 940E 0BAA CALL	_delay
(0331) 	 
(0332) 	 //move body on leg 3 & 4 
(0333) 	 angleMirror(LEG_4, MOTOR_A, 0);
    1137 2422      CLR	R2
    1138 8228      STD	Y+0,R2
    1139 E421      LDI	R18,0x41
    113A E030      LDI	R19,0
    113B E004      LDI	R16,4
    113C E010      LDI	R17,0
    113D 940E 0DA3 CALL	_angleMirror
(0334) 	 angleMirror(LEG_1, MOTOR_C, 0);
    113F 2422      CLR	R2
    1140 8228      STD	Y+0,R2
    1141 E423      LDI	R18,0x43
    1142 E030      LDI	R19,0
    1143 E001      LDI	R16,1
    1144 E010      LDI	R17,0
    1145 940E 0DA3 CALL	_angleMirror
(0335) 	 	 	 
(0336) 	 delay(delay_time2);
    1147 018B      MOVW	R16,R22
    1148 940E 0BAA CALL	_delay
(0337) 	 
(0338) 	 angleMirror(LEG_1, MOTOR_C, 90);
    114A E58A      LDI	R24,0x5A
    114B 8388      STD	Y+0,R24
    114C E423      LDI	R18,0x43
    114D E030      LDI	R19,0
    114E E001      LDI	R16,1
    114F E010      LDI	R17,0
    1150 940E 0DA3 CALL	_angleMirror
(0339) 	 angleMirror(LEG_1, MOTOR_B, 90);
    1152 E58A      LDI	R24,0x5A
    1153 8388      STD	Y+0,R24
    1154 E422      LDI	R18,0x42
    1155 E030      LDI	R19,0
    1156 E001      LDI	R16,1
    1157 E010      LDI	R17,0
    1158 940E 0DA3 CALL	_angleMirror
(0340) 	 
(0341) 	 delay(delay_time1);
    115A 018A      MOVW	R16,R20
    115B 940E 0BAA CALL	_delay
(0342) 	 
(0343) 	 
(0344) 	 //drag body forward on legs 1 & 2 
(0345) 	 angleMirror(LEG_1, MOTOR_A, 0);
    115D 2422      CLR	R2
    115E 8228      STD	Y+0,R2
    115F E421      LDI	R18,0x41
    1160 E030      LDI	R19,0
    1161 E001      LDI	R16,1
    1162 E010      LDI	R17,0
    1163 940E 0DA3 CALL	_angleMirror
(0346) 	 
(0347) 	 delay(delay_time2);
    1165 018B      MOVW	R16,R22
    1166 940E 0BAA CALL	_delay
(0348) 	
(0349) 	
(0350) 	 //pick up 3 & 4
(0351) 	 angleMirror(LEG_4, MOTOR_B, 0);
    1168 2422      CLR	R2
    1169 8228      STD	Y+0,R2
    116A E422      LDI	R18,0x42
    116B E030      LDI	R19,0
    116C E004      LDI	R16,4
    116D E010      LDI	R17,0
    116E 940E 0DA3 CALL	_angleMirror
(0352) 	 angleMirror(LEG_4, MOTOR_C, 0);
    1170 2422      CLR	R2
    1171 8228      STD	Y+0,R2
    1172 E423      LDI	R18,0x43
    1173 E030      LDI	R19,0
    1174 E004      LDI	R16,4
    1175 E010      LDI	R17,0
    1176 940E 0DA3 CALL	_angleMirror
(0353) 	
(0354) 	
(0355) 	 delay(delay_time1);
    1178 018A      MOVW	R16,R20
    1179 940E 0BAA CALL	_delay
(0356) 	
(0357) 	 //move forward in air 
(0358) 	 angleMirror(LEG_4, MOTOR_A, 180);
    117B EB84      LDI	R24,0xB4
    117C 8388      STD	Y+0,R24
    117D E421      LDI	R18,0x41
    117E E030      LDI	R19,0
    117F E004      LDI	R16,4
    1180 E010      LDI	R17,0
    1181 940E 0DA3 CALL	_angleMirror
(0359) 	
(0360) 	 delay(delay_time1);
    1183 018A      MOVW	R16,R20
    1184 940E 0BAA CALL	_delay
(0361) 	
(0362) 	//put 3 & 4 down
(0363) 	angleMirror(LEG_4, MOTOR_B, 50);
    1186 E382      LDI	R24,0x32
    1187 8388      STD	Y+0,R24
    1188 E422      LDI	R18,0x42
    1189 E030      LDI	R19,0
    118A E004      LDI	R16,4
    118B E010      LDI	R17,0
    118C 940E 0DA3 CALL	_angleMirror
(0364) 	angleMirror(LEG_4, MOTOR_C, 50);
    118E E382      LDI	R24,0x32
    118F 8388      STD	Y+0,R24
    1190 E423      LDI	R18,0x43
    1191 E030      LDI	R19,0
    1192 E004      LDI	R16,4
    1193 E010      LDI	R17,0
    1194 940E 0DA3 CALL	_angleMirror
(0365) 	
(0366) 	delay(delay_time1);
    1196 018A      MOVW	R16,R20
    1197 940E 0BAA CALL	_delay
(0367) 	
(0368) 	//push body on 3 & 4
(0369) 	angleMirror(LEG_4, MOTOR_A, 0);
    1199 2422      CLR	R2
    119A 8228      STD	Y+0,R2
    119B E421      LDI	R18,0x41
    119C E030      LDI	R19,0
    119D E004      LDI	R16,4
    119E E010      LDI	R17,0
    119F 940E 0DA3 CALL	_angleMirror
(0370) 	
(0371) 	delay(delay_time2);
    11A1 018B      MOVW	R16,R22
    11A2 940E 0BAA CALL	_delay
(0372) 	
(0373) 	// make this more smooth
(0374) 	//make hexapod sit
(0375) 	angleMirror(LEG_4, MOTOR_B, 0);
    11A4 2422      CLR	R2
    11A5 8228      STD	Y+0,R2
    11A6 E422      LDI	R18,0x42
    11A7 E030      LDI	R19,0
    11A8 E004      LDI	R16,4
    11A9 E010      LDI	R17,0
    11AA 940E 0DA3 CALL	_angleMirror
(0376) 	angleMirror(LEG_4, MOTOR_C, 180);
    11AC EB84      LDI	R24,0xB4
    11AD 8388      STD	Y+0,R24
    11AE E423      LDI	R18,0x43
    11AF E030      LDI	R19,0
    11B0 E004      LDI	R16,4
    11B1 E010      LDI	R17,0
    11B2 940E 0DA3 CALL	_angleMirror
(0377) 	delay(delay_time1);
    11B4 018A      MOVW	R16,R20
    11B5 940E 0BAA CALL	_delay
(0378) 	
(0379) 	angleMirror(LEG_1, MOTOR_B, 0);
    11B7 2422      CLR	R2
    11B8 8228      STD	Y+0,R2
    11B9 E422      LDI	R18,0x42
    11BA E030      LDI	R19,0
    11BB E001      LDI	R16,1
    11BC E010      LDI	R17,0
    11BD 940E 0DA3 CALL	_angleMirror
(0380) 	
(0381) 	delay(delay_time1);	
    11BF 018A      MOVW	R16,R20
    11C0 940E 0BAA CALL	_delay
(0382) 	
(0383) 	angleMirror(LEG_4, MOTOR_A, 90);
    11C2 E58A      LDI	R24,0x5A
    11C3 8388      STD	Y+0,R24
    11C4 E421      LDI	R18,0x41
    11C5 E030      LDI	R19,0
    11C6 E004      LDI	R16,4
    11C7 E010      LDI	R17,0
    11C8 940E 0DA3 CALL	_angleMirror
(0384) 	 
(0385) 	delay(delay_time1);
    11CA 018A      MOVW	R16,R20
    11CB 940E 0BAA CALL	_delay
(0386) 	 
(0387) 	//pick up legs 5 & 6
(0388) 	angleMirror(LEG_5, MOTOR_B, 0);
    11CD 2422      CLR	R2
    11CE 8228      STD	Y+0,R2
    11CF E422      LDI	R18,0x42
    11D0 E030      LDI	R19,0
    11D1 E005      LDI	R16,5
    11D2 E010      LDI	R17,0
    11D3 940E 0DA3 CALL	_angleMirror
(0389) 	angleMirror(LEG_5, MOTOR_C, 180);
    11D5 EB84      LDI	R24,0xB4
    11D6 8388      STD	Y+0,R24
    11D7 E423      LDI	R18,0x43
    11D8 E030      LDI	R19,0
    11D9 E005      LDI	R16,5
    11DA E010      LDI	R17,0
    11DB 940E 0DA3 CALL	_angleMirror
(0390) 	 
(0391) 	delay(delay_time1);
    11DD 018A      MOVW	R16,R20
    11DE 940E 0BAA CALL	_delay
(0392) 	 
(0393) 	//move legs 5 & 6 in air 
(0394) 	angleMirror(LEG_5, MOTOR_A, 180);
    11E0 EB84      LDI	R24,0xB4
    11E1 8388      STD	Y+0,R24
    11E2 E421      LDI	R18,0x41
    11E3 E030      LDI	R19,0
    11E4 E005      LDI	R16,5
    11E5 E010      LDI	R17,0
    11E6 940E 0DA3 CALL	_angleMirror
(0395) 	 
(0396) 	delay(delay_time1);
    11E8 018A      MOVW	R16,R20
    11E9 940E 0BAA CALL	_delay
(0397) 	 
(0398) 	//crawl on 1, 2 , 3 ,4
(0399) 	angleMirror(LEG_1, MOTOR_A, 180);
    11EB EB84      LDI	R24,0xB4
    11EC 8388      STD	Y+0,R24
    11ED E421      LDI	R18,0x41
    11EE E030      LDI	R19,0
    11EF E001      LDI	R16,1
    11F0 E010      LDI	R17,0
    11F1 940E 0DA3 CALL	_angleMirror
(0400) 	angleMirror(LEG_4, MOTOR_A, 180);
    11F3 EB84      LDI	R24,0xB4
    11F4 8388      STD	Y+0,R24
    11F5 E421      LDI	R18,0x41
    11F6 E030      LDI	R19,0
    11F7 E004      LDI	R16,4
    11F8 E010      LDI	R17,0
    11F9 940E 0DA3 CALL	_angleMirror
(0401) 	 
(0402) 	delay(delay_time2);
    11FB 018B      MOVW	R16,R22
    11FC 940E 0BAA CALL	_delay
(0403) 	 
(0404) 	//put down 1, 2, 3, 4
(0405) 	angleMirror(LEG_1, MOTOR_B, 50);
    11FE E382      LDI	R24,0x32
    11FF 8388      STD	Y+0,R24
    1200 E422      LDI	R18,0x42
    1201 E030      LDI	R19,0
    1202 E001      LDI	R16,1
    1203 E010      LDI	R17,0
    1204 940E 0DA3 CALL	_angleMirror
(0406) 	angleMirror(LEG_1, MOTOR_C, 50);
    1206 E382      LDI	R24,0x32
    1207 8388      STD	Y+0,R24
    1208 E423      LDI	R18,0x43
    1209 E030      LDI	R19,0
    120A E001      LDI	R16,1
    120B E010      LDI	R17,0
    120C 940E 0DA3 CALL	_angleMirror
(0407) 	angleMirror(LEG_4, MOTOR_B, 50);
    120E E382      LDI	R24,0x32
    120F 8388      STD	Y+0,R24
    1210 E422      LDI	R18,0x42
    1211 E030      LDI	R19,0
    1212 E004      LDI	R16,4
    1213 E010      LDI	R17,0
    1214 940E 0DA3 CALL	_angleMirror
(0408) 	angleMirror(LEG_4, MOTOR_C, 50);
    1216 E382      LDI	R24,0x32
    1217 8388      STD	Y+0,R24
    1218 E423      LDI	R18,0x43
    1219 E030      LDI	R19,0
    121A E004      LDI	R16,4
    121B E010      LDI	R17,0
    121C 940E 0DA3 CALL	_angleMirror
(0409) 	 
(0410) 	delay(delay_time1);
    121E 018A      MOVW	R16,R20
    121F 940E 0BAA CALL	_delay
(0411) 	 
(0412) 	//crawl on 1, 2 , 3 ,4
(0413) 	angleMirror(LEG_1, MOTOR_A, 0);
    1221 2422      CLR	R2
    1222 8228      STD	Y+0,R2
    1223 E421      LDI	R18,0x41
    1224 E030      LDI	R19,0
    1225 E001      LDI	R16,1
    1226 E010      LDI	R17,0
    1227 940E 0DA3 CALL	_angleMirror
(0414) 	angleMirror(LEG_4, MOTOR_A, 0);
    1229 2422      CLR	R2
    122A 8228      STD	Y+0,R2
    122B E421      LDI	R18,0x41
    122C E030      LDI	R19,0
    122D E004      LDI	R16,4
    122E E010      LDI	R17,0
    122F 940E 0DA3 CALL	_angleMirror
(0415) 	
(0416) 	delay(delay_time2);
    1231 018B      MOVW	R16,R22
    1232 940E 0BAA CALL	_delay
(0417) 	 
(0418) 	 
(0419) 	//put down 5 & 6 
(0420) 	angleMirror(LEG_5, MOTOR_B, 50);
    1234 E382      LDI	R24,0x32
    1235 8388      STD	Y+0,R24
    1236 E422      LDI	R18,0x42
    1237 E030      LDI	R19,0
    1238 E005      LDI	R16,5
    1239 E010      LDI	R17,0
    123A 940E 0DA3 CALL	_angleMirror
(0421) 	angleMirror(LEG_5, MOTOR_C, 50);
    123C E382      LDI	R24,0x32
    123D 8388      STD	Y+0,R24
    123E E423      LDI	R18,0x43
    123F E030      LDI	R19,0
    1240 E005      LDI	R16,5
    1241 E010      LDI	R17,0
    1242 940E 0DA3 CALL	_angleMirror
(0422) 	 
(0423) 	delay(delay_time1);
    1244 018A      MOVW	R16,R20
    1245 940E 0BAA CALL	_delay
(0424) 	 
(0425) 	//stand up and dance
(0426) 	 
(0427) 	angleMirror(LEG_1, MOTOR_B, 90);
    1247 E58A      LDI	R24,0x5A
    1248 8388      STD	Y+0,R24
    1249 E422      LDI	R18,0x42
    124A E030      LDI	R19,0
    124B E001      LDI	R16,1
    124C E010      LDI	R17,0
    124D 940E 0DA3 CALL	_angleMirror
(0428) 	angleMirror(LEG_1, MOTOR_C, 90);
    124F E58A      LDI	R24,0x5A
    1250 8388      STD	Y+0,R24
    1251 E423      LDI	R18,0x43
    1252 E030      LDI	R19,0
    1253 E001      LDI	R16,1
    1254 E010      LDI	R17,0
    1255 940E 0DA3 CALL	_angleMirror
(0429) 	angleMirror(LEG_4, MOTOR_B, 90);
    1257 E58A      LDI	R24,0x5A
    1258 8388      STD	Y+0,R24
    1259 E422      LDI	R18,0x42
    125A E030      LDI	R19,0
    125B E004      LDI	R16,4
    125C E010      LDI	R17,0
    125D 940E 0DA3 CALL	_angleMirror
(0430) 	angleMirror(LEG_4, MOTOR_C, 90);
    125F E58A      LDI	R24,0x5A
    1260 8388      STD	Y+0,R24
    1261 E423      LDI	R18,0x43
    1262 E030      LDI	R19,0
    1263 E004      LDI	R16,4
    1264 E010      LDI	R17,0
    1265 940E 0DA3 CALL	_angleMirror
(0431) 	angleMirror(LEG_5, MOTOR_B, 90);
    1267 E58A      LDI	R24,0x5A
    1268 8388      STD	Y+0,R24
    1269 E422      LDI	R18,0x42
    126A E030      LDI	R19,0
    126B E005      LDI	R16,5
    126C E010      LDI	R17,0
    126D 940E 0DA3 CALL	_angleMirror
(0432) 	angleMirror(LEG_5, MOTOR_C, 90);
    126F E58A      LDI	R24,0x5A
    1270 8388      STD	Y+0,R24
    1271 E423      LDI	R18,0x43
    1272 E030      LDI	R19,0
    1273 E005      LDI	R16,5
    1274 E010      LDI	R17,0
    1275 940E 0DA3 CALL	_angleMirror
(0433) 	 
(0434) 	delay(delay_time1);
    1277 018A      MOVW	R16,R20
    1278 940E 0BAA CALL	_delay
(0435) 	 
(0436) 	angleMirror(LEG_5, MOTOR_A, 90);
    127A E58A      LDI	R24,0x5A
    127B 8388      STD	Y+0,R24
    127C E421      LDI	R18,0x41
    127D E030      LDI	R19,0
    127E E005      LDI	R16,5
    127F E010      LDI	R17,0
    1280 940E 0DA3 CALL	_angleMirror
(0437) 	 
(0438) 	delay(ONE_SEC);
    1282 E900      LDI	R16,0x90
    1283 E011      LDI	R17,1
    1284 940E 0BAA CALL	_delay
(0439) 	 
(0440) 	servo_calibration(); //must be called as the first instruction
    1286 940E 09DD CALL	_servo_calibration
(0441) 	 
(0442) 	delay(ONE_SEC);
    1288 E900      LDI	R16,0x90
    1289 E011      LDI	R17,1
    128A 940E 0BAA CALL	_delay
    128C 9621      ADIW	R28,1
    128D 940C 13CA JMP	pop_xgsetF000
_walk_on_four:
  i                    --> R10
  lift                 --> R22
  delay_time           --> R20
    128F 940E 13CF CALL	push_xgsetF00C
    1291 9722      SBIW	R28,2
(0443) 	 
(0444) 	 	 
(0445) }
(0446) 
(0447) /**
(0448) The hexapod moves on four legs
(0449) This method doesnt work as planned
(0450) */
(0451) void walk_on_four() {
(0452) 	 
(0453) 	 unsigned char lift = 120;
    1292 E768      LDI	R22,0x78
(0454) 	 unsigned char delay_time  = HUNDRED_MSEC;
    1293 E248      LDI	R20,0x28
(0455) 	 int i = 10;
    1294 E08A      LDI	R24,0xA
    1295 E090      LDI	R25,0
    1296 015C      MOVW	R10,R24
(0456) 	 //come to pose
(0457) 	 pose(1,2,0);
    1297 2422      CLR	R2
    1298 2433      CLR	R3
    1299 8239      STD	Y+1,R3
    129A 8228      STD	Y+0,R2
    129B E022      LDI	R18,2
    129C E001      LDI	R16,1
    129D DB3A      RCALL	_pose
(0458) 	 
(0459) 	 delay(ONE_SEC);
    129E E900      LDI	R16,0x90
    129F E011      LDI	R17,1
    12A0 940E 0BAA CALL	_delay
(0460) 	 delay(ONE_SEC);
    12A2 E900      LDI	R16,0x90
    12A3 E011      LDI	R17,1
    12A4 940E 0BAA CALL	_delay
    12A6 C03E      RJMP	0x12E5
(0461) 	 
(0462) 	 
(0463) 	 while(i-- > 0) {
(0464) 	 
(0465) 	 //adjust body weight
(0466) 	 //angle(LEG_6, MOTOR_A, 90 - 50);	
(0467) 	 //angle(LEG_5, MOTOR_A, 90 + 50);
(0468) 	 
(0469) 	 //delay(ONE_SEC);
(0470) 	 
(0471) 	 angle(LEG_3, MOTOR_B, lift);
    12A7 8368      STD	Y+0,R22
    12A8 E422      LDI	R18,0x42
    12A9 E003      LDI	R16,3
    12AA 940E 0BFD CALL	_angle
(0472) 	 angle(LEG_4, MOTOR_B, 180);
    12AC EB84      LDI	R24,0xB4
    12AD 8388      STD	Y+0,R24
    12AE E422      LDI	R18,0x42
    12AF E004      LDI	R16,4
    12B0 940E 0BFD CALL	_angle
(0473) 	 
(0474) 	 delay(delay_time);
    12B2 2F04      MOV	R16,R20
    12B3 2711      CLR	R17
    12B4 940E 0BAA CALL	_delay
(0475) 	 
(0476) 	 //move left forward leg forward in air
(0477) 	 angle(LEG_3, MOTOR_A, 70);
    12B6 E486      LDI	R24,0x46
    12B7 8388      STD	Y+0,R24
    12B8 E421      LDI	R18,0x41
    12B9 E003      LDI	R16,3
    12BA 940E 0BFD CALL	_angle
(0478) 	 angle(LEG_4, MOTOR_A, 90);
    12BC E58A      LDI	R24,0x5A
    12BD 8388      STD	Y+0,R24
    12BE E421      LDI	R18,0x41
    12BF E004      LDI	R16,4
    12C0 940E 0BFD CALL	_angle
(0479) 	 
(0480) 	 delay(delay_time);
    12C2 2F04      MOV	R16,R20
    12C3 2711      CLR	R17
    12C4 940E 0BAA CALL	_delay
(0481) 	 
(0482) 	 angle(LEG_3, MOTOR_B, 180);
    12C6 EB84      LDI	R24,0xB4
    12C7 8388      STD	Y+0,R24
    12C8 E422      LDI	R18,0x42
    12C9 E003      LDI	R16,3
    12CA 940E 0BFD CALL	_angle
(0483) 	 angle(LEG_4, MOTOR_B, lift);
    12CC 8368      STD	Y+0,R22
    12CD E422      LDI	R18,0x42
    12CE E004      LDI	R16,4
    12CF 940E 0BFD CALL	_angle
(0484) 	 
(0485) 	 delay(delay_time);
    12D1 2F04      MOV	R16,R20
    12D2 2711      CLR	R17
    12D3 940E 0BAA CALL	_delay
(0486) 	 
(0487) 	 angle(LEG_3, MOTOR_A, 90);
    12D5 E58A      LDI	R24,0x5A
    12D6 8388      STD	Y+0,R24
    12D7 E421      LDI	R18,0x41
    12D8 E003      LDI	R16,3
    12D9 940E 0BFD CALL	_angle
(0488) 	 angle(LEG_4, MOTOR_A, 70);
    12DB E486      LDI	R24,0x46
    12DC 8388      STD	Y+0,R24
    12DD E421      LDI	R18,0x41
    12DE E004      LDI	R16,4
    12DF 940E 0BFD CALL	_angle
(0489) 	 	 
(0490) 	 delay(delay_time);
    12E1 2F04      MOV	R16,R20
    12E2 2711      CLR	R17
    12E3 940E 0BAA CALL	_delay
    12E5 0125      MOVW	R4,R10
    12E6 01C2      MOVW	R24,R4
    12E7 9701      SBIW	R24,1
    12E8 015C      MOVW	R10,R24
    12E9 2422      CLR	R2
    12EA 2433      CLR	R3
    12EB 1424      CP	R2,R4
    12EC 0435      CPC	R3,R5
    12ED F40C      BGE	0x12EF
    12EE CFB8      RJMP	0x12A7
    12EF 9622      ADIW	R28,2
    12F0 940C 13D6 JMP	pop_xgsetF00C
_keyboard_control:
    12F2 934A      ST	R20,-Y
    12F3 935A      ST	R21,-Y
    12F4 9722      SBIW	R28,2
FILE: D:\BUILDI~1\keyboard.c
(0001) /***
(0002) Author : Srijit Dutt
(0003) Date Sun 07 Nov 2010 02:42:38 PM IST 
(0004) 
(0005) keyboard.c : File contains various advanced motion functions for the hexapod
(0006) Please include keyboard.h file to call function from this file
(0007) 
(0008) The various functions are : 
(0009) keyboard_control
(0010) */
(0011) 
(0012) /*********************************************************************************
(0013) 
(0014)    Copyright (c) 2010, ERTS Lab IIT Bombay erts@cse.iitb.ac.in               -*- c -*-
(0015)    All rights reserved.
(0016) 
(0017)    Redistribution and use in source and binary forms, with or without
(0018)    modification, are permitted provided that the following conditions are met:
(0019) 
(0020)    * Redistributions of source code must retain the above copyright
(0021)      notice, this list of conditions and the following disclaimer.
(0022) 
(0023)    * Redistributions in binary form must reproduce the above copyright
(0024)      notice, this list of conditions and the following disclaimer in
(0025)      the documentation and/or other materials provided with the
(0026)      distribution.
(0027) 
(0028)    * Neither the name of the copyright holders nor the names of
(0029)      contributors may be used to endorse or promote products derived
(0030)      from this software without specific prior written permission.
(0031) 
(0032)    * Source code can be used for academic purpose. 
(0033) 	 For commercial use permission form the author needs to be taken.
(0034) 
(0035)   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
(0036)   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
(0037)   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
(0038)   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
(0039)   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
(0040)   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
(0041)   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
(0042)   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
(0043)   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
(0044)   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
(0045)   POSSIBILITY OF SUCH DAMAGE. 
(0046) 
(0047)   Software released under Creative Commence cc by-nc-sa licence.
(0048)   For legal information refer to: 
(0049)   http://creativecommons.org/licenses/by-nc-sa/3.0/legalcode
(0050) 
(0051) ********************************************************************************/
(0052) 
(0053) 
(0054) 
(0055) 
(0056) #include "hexapod_macro.h"
(0057) #include "hexapod.h"
(0058) #include "gait.h"
(0059) #include "hexapod_motions.h"
(0060) #include "hexapod_basic.h"
(0061) 
(0062) 
(0063) extern unsigned char data;//!< The keyborad command given by user
(0064) 
(0065) 
(0066) /**
(0067) Controls hexapod through keyboard using ZigBee communication
(0068) */
(0069) void keyboard_control(void) {
(0070) 	
(0071) 	static char change = 15;
(0072) 	
(0073) 	switch(data) {
    12F5 9140 020E LDS	R20,data
    12F7 2755      CLR	R21
    12F8 334C      CPI	R20,0x3C
    12F9 E0E0      LDI	R30,0
    12FA 075E      CPC	R21,R30
    12FB F409      BNE	0x12FD
    12FC C070      RJMP	0x136D
    12FD 334E      CPI	R20,0x3E
    12FE E0E0      LDI	R30,0
    12FF 075E      CPC	R21,R30
    1300 F409      BNE	0x1302
    1301 C068      RJMP	0x136A
    1302 334C      CPI	R20,0x3C
    1303 E0E0      LDI	R30,0
    1304 075E      CPC	R21,R30
    1305 F40C      BGE	0x1307
    1306 C069      RJMP	0x1370
    1307 3641      CPI	R20,0x61
    1308 E0E0      LDI	R30,0
    1309 075E      CPC	R21,R30
    130A F40C      BGE	0x130C
    130B C064      RJMP	0x1370
    130C E78A      LDI	R24,0x7A
    130D E090      LDI	R25,0
    130E 1784      CP	R24,R20
    130F 0795      CPC	R25,R21
    1310 F40C      BGE	0x1312
    1311 C05E      RJMP	0x1370
    1312 E003      LDI	R16,3
    1313 E010      LDI	R17,0
    1314 019A      MOVW	R18,R20
    1315 940E 1396 CALL	empy16s
    1317 01F8      MOVW	R30,R16
    1318 EC81      LDI	R24,0xC1
    1319 EF9F      LDI	R25,0xFF
    131A 0FE8      ADD	R30,R24
    131B 1FF9      ADC	R31,R25
    131C 9027      ELPM	R2,Z+
    131D 9037      ELPM	R3,Z+
    131E 9006      ELPM	R0,255(Z)
    131F BE0C      OUT	0x3C,R0
    1320 01F1      MOVW	R30,R2
    1321 9419      IJMP
(0074) 	   case 's':
(0075) 	   		servo_calibration();
    1322 940E 09DD CALL	_servo_calibration
(0076) 	   		break;
    1324 C04D      RJMP	0x1372
(0077) 	   case 'w': 
(0078) 	         tripod_gait(LEG_2, 1);
    1325 E021      LDI	R18,1
    1326 E002      LDI	R16,2
    1327 940E 016B CALL	_tripod_gait
(0079) 			 break;	
    1329 C048      RJMP	0x1372
(0080) 	   case 'e': 
(0081) 	         tripod_gait(LEG_1, 1);
    132A E021      LDI	R18,1
    132B E001      LDI	R16,1
    132C 940E 016B CALL	_tripod_gait
(0082) 			 break;
    132E C043      RJMP	0x1372
(0083) 	   case 'd': 
(0084) 	         tripod_gait(LEG_4, 1);
    132F E021      LDI	R18,1
    1330 E004      LDI	R16,4
    1331 940E 016B CALL	_tripod_gait
(0085) 			 break;
    1333 C03E      RJMP	0x1372
(0086) 	   case 'x': 
(0087) 	         tripod_gait(LEG_5, 1);
    1334 E021      LDI	R18,1
    1335 E005      LDI	R16,5
    1336 940E 016B CALL	_tripod_gait
(0088) 			 break;
    1338 C039      RJMP	0x1372
(0089) 	   case 'z': 
(0090) 	         tripod_gait(LEG_6, 1);
    1339 E021      LDI	R18,1
    133A E006      LDI	R16,6
    133B 940E 016B CALL	_tripod_gait
(0091) 			 break;
    133D C034      RJMP	0x1372
(0092) 	   case 'a': 
(0093) 	         tripod_gait(LEG_3, 1);
    133E E021      LDI	R18,1
    133F E003      LDI	R16,3
    1340 940E 016B CALL	_tripod_gait
(0094) 			 break;	 	
    1342 C02F      RJMP	0x1372
(0095) 	   case 't': 
(0096) 			two_leg_gait(1, 2, 1);
    1343 E081      LDI	R24,1
    1344 E090      LDI	R25,0
    1345 8399      STD	Y+1,R25
    1346 8388      STD	Y+0,R24
    1347 E022      LDI	R18,2
    1348 E001      LDI	R16,1
    1349 940E 03C0 CALL	_two_leg_gait
(0097) 			break;
    134B C026      RJMP	0x1372
(0098) 	   case 'b':
(0099) 	   		buzzer_on_off();
    134C 940E 0D34 CALL	_buzzer_on_off
(0100) 			break;
    134E C023      RJMP	0x1372
(0101) 	   case 'p':
(0102) 	   		pose(LEG_1, LEG_2, 10);
    134F E08A      LDI	R24,0xA
    1350 E090      LDI	R25,0
    1351 8399      STD	Y+1,R25
    1352 8388      STD	Y+0,R24
    1353 E022      LDI	R18,2
    1354 E001      LDI	R16,1
    1355 940E 0DD8 CALL	_pose
(0103) 			break;
    1357 C01A      RJMP	0x1372
(0104) 	   case 'k':
(0105) 	        sway(24, CLOCK_WISE);
    1358 E021      LDI	R18,1
    1359 E108      LDI	R16,0x18
    135A E010      LDI	R17,0
    135B 940E 0F52 CALL	_sway
(0106) 	        break;
    135D C014      RJMP	0x1372
(0107) 	   case 'l':
(0108) 	        dance(4,5,6);
    135E E086      LDI	R24,6
    135F E090      LDI	R25,0
    1360 8399      STD	Y+1,R25
    1361 8388      STD	Y+0,R24
    1362 E025      LDI	R18,5
    1363 E004      LDI	R16,4
    1364 940E 0EA7 CALL	_dance
(0109) 	        break;				
    1366 C00B      RJMP	0x1372
(0110) 	   case 'c' :
(0111) 	        climb();
    1367 940E 105C CALL	_climb
(0112) 			break;
    1369 C008      RJMP	0x1372
(0113) 	   case '>' :
(0114) 		    robot_rotate_clockwise_7_5();
    136A 940E 0A7A CALL	_robot_rotate_clockwise_7_5
(0115) 			break;	
    136C C005      RJMP	0x1372
(0116) 	   case '<' :
(0117) 		    robot_rotate_anticlockwise_7_5();
    136D 940E 0A99 CALL	_robot_rotate_anticlockwise_7_5
(0118) 			break;		
    136F C002      RJMP	0x1372
(0119) 			
(0120) 	   /*case '+':
(0121) 	        angle_change(LEG_1, MOTOR_A, change);
(0122) 			break;
(0123) 	   case '-':
(0124) 	        angle_change(LEG_1, MOTOR_A, -change);
(0125) 			break;	
(0126) 	   case '*':
(0127) 	        change += 5;
(0128) 			if(change > 90)
(0129) 			    change = 90;
(0130) 			break;
(0131) 	   case '/':
(0132) 	        change += -5;
(0133) 			if(change < 5)
(0134) 			   change = 5;
(0135) 			break;*/
(0136) 			
(0137) 			
(0138) 		/*	
(0139) 	   case '`':
(0140) 	        angle_change(LEG_1, MOTOR_A, change);
(0141) 			break;
(0142) 	   case '~':
(0143) 	        angle_change(LEG_1, MOTOR_A, -change);
(0144) 			break;
(0145) 	   case '1':
(0146) 	        angle_change(LEG_1, MOTOR_B, change);
(0147) 			break;
(0148) 	   case '!':
(0149) 	        angle_change(LEG_1, MOTOR_B, -change);
(0150) 			break;
(0151) 		case '2':
(0152) 	        angle_change(LEG_1, MOTOR_C, change);
(0153) 			break;
(0154) 	   case '@':
(0155) 	        angle_change(LEG_1, MOTOR_C, -change);
(0156) 			break;
(0157) 			
(0158) 		case '3':
(0159) 	        angle_change(LEG_2, MOTOR_A, change);
(0160) 			break;
(0161) 	   case '#':
(0162) 	        angle_change(LEG_2, MOTOR_A, -change);
(0163) 			break;
(0164) 	   case '4':
(0165) 	        angle_change(LEG_2, MOTOR_B, change);
(0166) 			break;
(0167) 	   case '$':
(0168) 	        angle_change(LEG_2, MOTOR_B, -change);
(0169) 			break;
(0170) 		case '5':
(0171) 	        angle_change(LEG_2, MOTOR_C, change);
(0172) 			break;
(0173) 	   case '%':
(0174) 	        angle_change(LEG_2, MOTOR_C, -change);
(0175) 			break;
(0176) 		
(0177) 		case '6':
(0178) 	        angle_change(LEG_3, MOTOR_A, change);
(0179) 			break;
(0180) 	   case '^':
(0181) 	        angle_change(LEG_3, MOTOR_A, -change);
(0182) 			break;
(0183) 	   case '7':
(0184) 	        angle_change(LEG_3, MOTOR_B, change);
(0185) 			break;
(0186) 	   case '&':
(0187) 	        angle_change(LEG_3, MOTOR_B, -change);
(0188) 			break;
(0189) 		case '8':
(0190) 	        angle_change(LEG_3, MOTOR_C, change);
(0191) 			break;
(0192) 	   case '*':
(0193) 	        angle_change(LEG_3, MOTOR_C, -change);
(0194) 			break;
(0195) 		
(0196) 		case '9':
(0197) 	        angle_change(LEG_4, MOTOR_A, change);
(0198) 			break;
(0199) 	   case '(':
(0200) 	        angle_change(LEG_4, MOTOR_A, -change);
(0201) 			break;
(0202) 	   case '0':
(0203) 	        angle_change(LEG_4, MOTOR_B, change);
(0204) 			break;
(0205) 	   case ')':
(0206) 	        angle_change(LEG_4, MOTOR_B, -change);
(0207) 			break;
(0208) 		case '-':
(0209) 	        angle_change(LEG_4, MOTOR_C, change);
(0210) 			break;
(0211) 	   case '_':
(0212) 	        angle_change(LEG_4, MOTOR_C, -change);
(0213) 			break;
(0214) 		
(0215) 		case '=':
(0216) 	        angle_change(LEG_5, MOTOR_A, change);
(0217) 			break;
(0218) 	   case '+':
(0219) 	        angle_change(LEG_5, MOTOR_A, -change);
(0220) 			break;
(0221) 	   case '[':
(0222) 	        angle_change(LEG_5, MOTOR_B, change);
(0223) 			break;
(0224) 	   case '{':
(0225) 	        angle_change(LEG_5, MOTOR_B, -change);
(0226) 			break;
(0227) 		case ']':
(0228) 	        angle_change(LEG_5, MOTOR_C, change);
(0229) 			break;
(0230) 	   case '}':
(0231) 	        angle_change(LEG_5, MOTOR_C, -change);
(0232) 			break;
(0233) 		
(0234) 		case '\\':
(0235) 	        angle_change(LEG_6, MOTOR_A, change);
(0236) 			break;
(0237) 	   case '|':
(0238) 	        angle_change(LEG_6, MOTOR_A, -change);
(0239) 			break;
(0240) 	   case ';':
(0241) 	        angle_change(LEG_6, MOTOR_B, change);
(0242) 			break;
(0243) 	   case ':':
(0244) 	        angle_change(LEG_6, MOTOR_B, -change);
(0245) 			break;
(0246) 		case '\'':
(0247) 	        angle_change(LEG_6, MOTOR_C, change);
(0248) 			break;
(0249) 	   case '\"':
(0250) 	        angle_change(LEG_6, MOTOR_C, -change);
(0251) 			break;
(0252) 		*/		
(0253) 		default :
(0254) 		    buzzer_on();
    1370 940E 0BA4 CALL	_buzzer_on
(0255) 			break;
(0256) 	}	           
(0257) 	 	
(0258) 	data = '';
FILE: <library>
    1372 2422      CLR	R2
    1373 9220 020E STS	data,R2
    1375 9622      ADIW	R28,2
    1376 9159      LD	R21,Y+
    1377 9149      LD	R20,Y+
    1378 9508      RET
push_arg4:
    1379 933A      ST	R19,-Y
    137A 932A      ST	R18,-Y
push_arg2:
    137B 931A      ST	R17,-Y
    137C 930A      ST	R16,-Y
    137D 9508      RET
mod8u:
    137E 9468      BSET	6
    137F C001      RJMP	xdiv8u
div8u:
    1380 94E8      BCLR	6
xdiv8u:
    1381 932A      ST	R18,-Y
    1382 92FA      ST	R15,-Y
    1383 92EA      ST	R14,-Y
    1384 24FF      CLR	R15
    1385 24EE      CLR	R14
    1386 E120      LDI	R18,0x10
    1387 0F00      LSL	R16
    1388 1CFF      ROL	R15
    1389 1CEE      ROL	R14
    138A 16E1      CP	R14,R17
    138B F010      BCS	0x138E
    138C 1AE1      SUB	R14,R17
    138D 9503      INC	R16
    138E 952A      DEC	R18
    138F F7B9      BNE	0x1387
    1390 F40E      BRTC	0x1392
    1391 2D0E      MOV	R16,R14
    1392 90E9      LD	R14,Y+
    1393 90F9      LD	R15,Y+
    1394 9129      LD	R18,Y+
    1395 9508      RET
empy16s:
    1396 920A      ST	R0,-Y
    1397 921A      ST	R1,-Y
    1398 938A      ST	R24,-Y
    1399 939A      ST	R25,-Y
    139A 9F02      MUL	R16,R18
    139B 01C0      MOVW	R24,R0
    139C 9F12      MUL	R17,R18
    139D 0D90      ADD	R25,R0
    139E 9F03      MUL	R16,R19
    139F 0D90      ADD	R25,R0
    13A0 018C      MOVW	R16,R24
    13A1 9199      LD	R25,Y+
    13A2 9189      LD	R24,Y+
    13A3 9019      LD	R1,Y+
    13A4 9009      LD	R0,Y+
    13A5 9508      RET
pop_xgset30FC:
    13A6 90A9      LD	R10,Y+
    13A7 90B9      LD	R11,Y+
    13A8 90C9      LD	R12,Y+
    13A9 90D9      LD	R13,Y+
    13AA 90E9      LD	R14,Y+
    13AB 90F9      LD	R15,Y+
    13AC 9149      LD	R20,Y+
    13AD 9159      LD	R21,Y+
    13AE 9508      RET
pop_xgsetF0FC:
    13AF 90A9      LD	R10,Y+
    13B0 90B9      LD	R11,Y+
    13B1 90C9      LD	R12,Y+
    13B2 90D9      LD	R13,Y+
    13B3 90E9      LD	R14,Y+
    13B4 90F9      LD	R15,Y+
    13B5 9149      LD	R20,Y+
    13B6 9159      LD	R21,Y+
    13B7 9169      LD	R22,Y+
    13B8 9179      LD	R23,Y+
    13B9 9508      RET
push_xgsetF0FC:
    13BA 937A      ST	R23,-Y
    13BB 936A      ST	R22,-Y
push_xgset30FC:
    13BC 935A      ST	R21,-Y
    13BD 934A      ST	R20,-Y
push_xgset00FC:
    13BE 92FA      ST	R15,-Y
    13BF 92EA      ST	R14,-Y
push_xgset003C:
    13C0 92DA      ST	R13,-Y
    13C1 92CA      ST	R12,-Y
    13C2 92BA      ST	R11,-Y
    13C3 92AA      ST	R10,-Y
    13C4 9508      RET
push_xgsetF000:
    13C5 937A      ST	R23,-Y
    13C6 936A      ST	R22,-Y
    13C7 935A      ST	R21,-Y
    13C8 934A      ST	R20,-Y
    13C9 9508      RET
pop_xgsetF000:
    13CA 9149      LD	R20,Y+
    13CB 9159      LD	R21,Y+
    13CC 9169      LD	R22,Y+
    13CD 9179      LD	R23,Y+
    13CE 9508      RET
push_xgsetF00C:
    13CF 937A      ST	R23,-Y
    13D0 936A      ST	R22,-Y
    13D1 935A      ST	R21,-Y
    13D2 934A      ST	R20,-Y
    13D3 92BA      ST	R11,-Y
    13D4 92AA      ST	R10,-Y
    13D5 9508      RET
pop_xgsetF00C:
    13D6 90A9      LD	R10,Y+
    13D7 90B9      LD	R11,Y+
    13D8 9149      LD	R20,Y+
    13D9 9159      LD	R21,Y+
    13DA 9169      LD	R22,Y+
    13DB 9179      LD	R23,Y+
    13DC 9508      RET
push_xgsetF03C:
    13DD 937A      ST	R23,-Y
    13DE 936A      ST	R22,-Y
    13DF 935A      ST	R21,-Y
    13E0 934A      ST	R20,-Y
    13E1 92DA      ST	R13,-Y
    13E2 92CA      ST	R12,-Y
    13E3 92BA      ST	R11,-Y
    13E4 92AA      ST	R10,-Y
    13E5 9508      RET
pop_xgsetF03C:
    13E6 90A9      LD	R10,Y+
    13E7 90B9      LD	R11,Y+
    13E8 90C9      LD	R12,Y+
    13E9 90D9      LD	R13,Y+
    13EA 9149      LD	R20,Y+
    13EB 9159      LD	R21,Y+
    13EC 9169      LD	R22,Y+
    13ED 9179      LD	R23,Y+
    13EE 9508      RET
asgncblkx:
    13EF 93AA      ST	R26,-Y
    13F0 93BA      ST	R27,-Y
    13F1 93EA      ST	R30,-Y
    13F2 93FA      ST	R31,-Y
    13F3 920A      ST	R0,-Y
    13F4 81AF      LDD	R26,Y+7
    13F5 85B8      LDD	R27,Y+8
    13F6 81ED      LDD	R30,Y+5
    13F7 81FE      LDD	R31,Y+6
    13F8 3000      CPI	R16,0
    13F9 0701      CPC	R16,R17
    13FA F031      BEQ	0x1401
    13FB 95D8      ELPM
    13FC 920D      ST	R0,X+
    13FD 9631      ADIW	R30,1
    13FE 5001      SUBI	R16,1
    13FF 4010      SBCI	R17,0
    1400 CFF7      RJMP	0x13F8
    1401 9009      LD	R0,Y+
    1402 91F9      LD	R31,Y+
    1403 91E9      LD	R30,Y+
    1404 91B9      LD	R27,Y+
    1405 91A9      LD	R26,Y+
    1406 9624      ADIW	R28,4
    1407 9508      RET
